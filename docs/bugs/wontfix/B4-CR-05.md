# Finding Ticket: compile_mode Default vs No Legacy Code Policy

---

## Ticket Metadata

| Field | Value |
|-------|-------|
| **Ticket ID** | `B4-CR-05` |
| **Severity** | `P3` |
| **Status** | `open` |
| **Batch** | 4 |
| **Agent** | `codereview` |
| **Domain** | `simic` |
| **Assignee** | |
| **Created** | 2024-12-27 |
| **Updated** | 2024-12-27 |

---

## Location

| Field | Value |
|-------|-------|
| **File(s)** | `/home/john/esper-lite/src/esper/simic/agent/ppo.py` |
| **Line(s)** | `989-990` |
| **Function/Class** | `PPOAgent.load()` |

---

## Summary

**One-line summary:** `config.get('compile_mode', 'off')` provides a default for old checkpoints - conflicts with No Legacy Code Policy.

**Category:**
- [ ] Correctness bug
- [ ] Race condition / concurrency
- [ ] Memory leak / resource issue
- [ ] Performance bottleneck
- [ ] Numerical stability
- [ ] torch.compile compatibility
- [ ] Dead code / unwired functionality
- [x] API design / contract violation
- [ ] Test coverage gap
- [ ] Documentation / naming
- [ ] Defensive programming violation
- [x] Legacy code policy violation

---

## Detailed Description

### What's Wrong

The checkpoint loading uses a defensive default:

```python
# Lines 989-990
compile_mode = config.get('compile_mode', 'off')
```

Per the No Legacy Code Policy in CLAUDE.md:
> "No version checks, no feature flags for old behavior, no compatibility mode switches"

This `.get()` pattern is a backwards compatibility shim for checkpoints created before `compile_mode` was added.

### Complicating Factor

There's an explicit test `test_compile_mode_defaults_to_off_for_old_checkpoints` that validates this behavior, suggesting it was an intentional design decision.

---

## Recommended Fix

**Option A: Strict (per No Legacy Code Policy)**
```python
if 'compile_mode' not in config:
    raise RuntimeError(
        "Incompatible checkpoint: config.compile_mode is required. "
        "This checkpoint was created with an older version."
    )
compile_mode = config['compile_mode']
```

**Option B: Document as Exception**
Keep the current code but add a comment explaining why this is an intentional exception:

```python
# EXCEPTION TO NO LEGACY CODE POLICY:
# compile_mode was added in v2.1. For checkpoints from v2.0, we default
# to 'off' rather than requiring users to re-train. This exception was
# approved because compile_mode is a runtime optimization, not a correctness
# concern - the model weights are compatible regardless.
compile_mode = config.get('compile_mode', 'off')
```

---

## Verification

### How to Verify the Fix

- [ ] Decide on Option A (strict) or Option B (document exception)
- [ ] If Option A: remove or update the test `test_compile_mode_defaults_to_off_for_old_checkpoints`
- [ ] If Option B: add exception documentation

---

## Related Findings

- Duplicated in PyTorch report (PPO-5)

---

## Cross-Review

| Agent | Verdict | Evaluation |
|-------|---------|------------|
| **PyTorch** | ENDORSE (Option B) | `compile_mode` is a runtime optimization flag, not model architecture - weights are compatible regardless. Strict rejection would force retraining for a non-breaking change; document as exception since `torch.compile` can be applied post-load without correctness impact. |
| **DRL** | NEUTRAL | From an RL perspective, `compile_mode` is a pure runtime optimization with no effect on policy weights or training correctness. Failing on old checkpoints would force users to re-train for zero benefit; Option B (document as exception) is pragmatic and RL-safe. |
| **CodeReview** | OBJECT | The `.get()` with default here is NOT backwards compatibility - it is legitimate schema evolution handling for checkpoint deserialization. Per CLAUDE.md "Legitimate Uses" section, this falls under runtime config handling. Checkpoint fields may be absent in valid checkpoints from before a feature was added; this is not a legacy code shim but standard serialization versioning. Recommend closing as non-issue. |
