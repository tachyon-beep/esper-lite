# Esper Scry Implementation Plan: Stages 0.5 - 2

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the Scry WebSocket infrastructure — schema extensions, aiohttp server, and Vue scaffold that receives and displays snapshots.

**Architecture:** Scry extends the shared Overwatch schema with `BestRunEntry`, implements an aiohttp server (`ScryServer`) that streams `TuiSnapshot` over WebSocket, and provides a Vue 3 SPA that connects and displays raw JSON initially. Token-based auth protects LAN access.

**Tech Stack:** Python 3.11+, aiohttp (async HTTP/WebSocket), Vue 3 + Composition API, Vite, TypeScript.

---

## Prerequisites

- Branch: `feat/overwatch-textual-ui` (current)
- Stage 0 complete: `TuiSnapshot`, `SnapshotWriter`, `SnapshotReader` exist
- Read design doc: `docs/plans/2025-12-18-scry-design.md`

---

## Stage 0.5: Schema Extensions

### Task 1: Add BestRunEntry Schema

**Files:**
- Modify: `src/esper/karn/overwatch/schema.py`
- Modify: `tests/karn/overwatch/test_schema.py`

**Step 1: Write failing test for BestRunEntry**

```python
# tests/karn/overwatch/test_schema.py (append to file)

class TestBestRunEntry:
    """Tests for BestRunEntry dataclass."""

    def test_best_run_entry_creation(self) -> None:
        """BestRunEntry can be created with required fields."""
        from esper.karn.overwatch.schema import BestRunEntry

        entry = BestRunEntry(
            env_id=2,
            best_accuracy=82.1,
            cumulative_reward=47.3,
            param_delta=12500,
            slot_configs={"r0c1": "FOSSILIZED"},
            achieved_at_episode=42,
        )

        assert entry.env_id == 2
        assert entry.best_accuracy == 82.1
        assert entry.cumulative_reward == 47.3
        assert entry.param_delta == 12500
        assert entry.slot_configs == {"r0c1": "FOSSILIZED"}
        assert entry.achieved_at_episode == 42
        assert entry.dismissed is False  # default

    def test_best_run_entry_to_dict(self) -> None:
        """BestRunEntry serializes to dict."""
        from esper.karn.overwatch.schema import BestRunEntry

        entry = BestRunEntry(
            env_id=0,
            best_accuracy=79.5,
            cumulative_reward=35.2,
            param_delta=8000,
            slot_configs={"r0c0": "TRAINING", "r0c1": "BLENDING"},
            achieved_at_episode=30,
            dismissed=True,
        )

        d = entry.to_dict()

        assert d["env_id"] == 0
        assert d["best_accuracy"] == 79.5
        assert d["cumulative_reward"] == 35.2
        assert d["dismissed"] is True

    def test_best_run_entry_from_dict(self) -> None:
        """BestRunEntry deserializes from dict."""
        from esper.karn.overwatch.schema import BestRunEntry

        d = {
            "env_id": 1,
            "best_accuracy": 81.3,
            "cumulative_reward": 52.1,
            "param_delta": 15000,
            "slot_configs": {"r0c1": "FOSSILIZED"},
            "achieved_at_episode": 55,
            "dismissed": False,
        }

        entry = BestRunEntry.from_dict(d)

        assert entry.env_id == 1
        assert entry.best_accuracy == 81.3
        assert entry.achieved_at_episode == 55

    def test_best_run_entry_json_roundtrip(self) -> None:
        """BestRunEntry survives JSON serialization."""
        from esper.karn.overwatch.schema import BestRunEntry

        entry = BestRunEntry(
            env_id=3,
            best_accuracy=80.0,
            cumulative_reward=40.0,
            param_delta=10000,
            slot_configs={"r0c1": "BLENDING"},
            achieved_at_episode=25,
        )

        json_str = json.dumps(entry.to_dict())
        restored = BestRunEntry.from_dict(json.loads(json_str))

        assert restored.env_id == entry.env_id
        assert restored.best_accuracy == entry.best_accuracy
        assert restored.dismissed == entry.dismissed
```

**Step 2: Run test to verify it fails**

Run: `PYTHONPATH=src uv run pytest tests/karn/overwatch/test_schema.py::TestBestRunEntry -v`

Expected: FAIL with `ImportError: cannot import name 'BestRunEntry'`

**Step 3: Implement BestRunEntry**

Add after `FeedEvent` class in `src/esper/karn/overwatch/schema.py`:

```python
@dataclass
class BestRunEntry:
    """Entry in the Best Runs leaderboard (Scry extension).

    Tracks the top-performing environments for Goodhart detection:
    high accuracy + high reward = expected
    high accuracy + low reward = investigate
    """

    env_id: int
    best_accuracy: float
    cumulative_reward: float
    param_delta: int  # Parameter count delta from baseline
    slot_configs: dict[str, str]  # slot_id -> final stage name
    achieved_at_episode: int
    dismissed: bool = False  # User dismissed from leaderboard

    def to_dict(self) -> dict[str, Any]:
        """Convert to JSON-serializable dict."""
        return {
            "env_id": self.env_id,
            "best_accuracy": self.best_accuracy,
            "cumulative_reward": self.cumulative_reward,
            "param_delta": self.param_delta,
            "slot_configs": self.slot_configs,
            "achieved_at_episode": self.achieved_at_episode,
            "dismissed": self.dismissed,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> BestRunEntry:
        """Reconstruct from dict."""
        return cls(
            env_id=data["env_id"],
            best_accuracy=data["best_accuracy"],
            cumulative_reward=data["cumulative_reward"],
            param_delta=data["param_delta"],
            slot_configs=data.get("slot_configs", {}),
            achieved_at_episode=data["achieved_at_episode"],
            dismissed=data.get("dismissed", False),
        )
```

**Step 4: Run test to verify it passes**

Run: `PYTHONPATH=src uv run pytest tests/karn/overwatch/test_schema.py::TestBestRunEntry -v`

Expected: All 4 tests PASS

**Step 5: Commit**

```bash
git add src/esper/karn/overwatch/schema.py tests/karn/overwatch/test_schema.py
git commit -m "feat(scry): add BestRunEntry schema for leaderboard"
```

---

### Task 2: Extend TuiSnapshot with best_runs Field

**Files:**
- Modify: `src/esper/karn/overwatch/schema.py`
- Modify: `tests/karn/overwatch/test_schema.py`

**Step 1: Write failing test for best_runs field**

```python
# tests/karn/overwatch/test_schema.py (append to TestTuiSnapshot class)

    def test_tui_snapshot_with_best_runs(self) -> None:
        """TuiSnapshot contains best_runs leaderboard."""
        from esper.karn.overwatch.schema import (
            TuiSnapshot,
            ConnectionStatus,
            TamiyoState,
            BestRunEntry,
        )

        best_runs = [
            BestRunEntry(
                env_id=0,
                best_accuracy=82.1,
                cumulative_reward=47.2,
                param_delta=12500,
                slot_configs={"r0c1": "FOSSILIZED"},
                achieved_at_episode=42,
            ),
            BestRunEntry(
                env_id=2,
                best_accuracy=81.3,
                cumulative_reward=52.1,
                param_delta=14000,
                slot_configs={"r0c1": "FOSSILIZED"},
                achieved_at_episode=38,
            ),
        ]

        snap = TuiSnapshot(
            schema_version=1,
            captured_at="2025-12-18T12:00:00Z",
            connection=ConnectionStatus(True, 1000.0, 0.5),
            tamiyo=TamiyoState(),
            best_runs=best_runs,
        )

        assert len(snap.best_runs) == 2
        assert snap.best_runs[0].env_id == 0
        assert snap.best_runs[1].cumulative_reward == 52.1

    def test_tui_snapshot_best_runs_json_roundtrip(self) -> None:
        """TuiSnapshot best_runs survives JSON serialization."""
        from esper.karn.overwatch.schema import (
            TuiSnapshot,
            ConnectionStatus,
            TamiyoState,
            BestRunEntry,
        )

        original = TuiSnapshot(
            schema_version=1,
            captured_at="2025-12-18T12:00:00Z",
            connection=ConnectionStatus(True, 1000.0, 0.5),
            tamiyo=TamiyoState(),
            best_runs=[
                BestRunEntry(
                    env_id=1,
                    best_accuracy=80.0,
                    cumulative_reward=40.0,
                    param_delta=10000,
                    slot_configs={"r0c1": "TRAINING"},
                    achieved_at_episode=20,
                    dismissed=True,
                )
            ],
        )

        json_str = json.dumps(original.to_dict())
        restored = TuiSnapshot.from_dict(json.loads(json_str))

        assert len(restored.best_runs) == 1
        assert restored.best_runs[0].dismissed is True
        assert restored.best_runs[0].best_accuracy == 80.0
```

**Step 2: Run test to verify it fails**

Run: `PYTHONPATH=src uv run pytest tests/karn/overwatch/test_schema.py::TestTuiSnapshot::test_tui_snapshot_with_best_runs tests/karn/overwatch/test_schema.py::TestTuiSnapshot::test_tui_snapshot_best_runs_json_roundtrip -v`

Expected: FAIL (TypeError or KeyError — `best_runs` not handled)

**Step 3: Extend TuiSnapshot**

Modify `TuiSnapshot` class in `src/esper/karn/overwatch/schema.py`:

1. Add field after `envs_crit`:
```python
    # Best runs leaderboard (Scry extension, ignored by Overwatch TUI)
    best_runs: list[BestRunEntry] = field(default_factory=list)
```

2. Update `to_dict()` method — add to the return dict:
```python
            "best_runs": [e.to_dict() for e in self.best_runs],
```

3. Update `from_dict()` method — add to the return statement:
```python
            best_runs=[BestRunEntry.from_dict(e) for e in data.get("best_runs", [])],
```

**Step 4: Run test to verify it passes**

Run: `PYTHONPATH=src uv run pytest tests/karn/overwatch/test_schema.py::TestTuiSnapshot -v`

Expected: All TuiSnapshot tests PASS (including new ones)

**Step 5: Commit**

```bash
git add src/esper/karn/overwatch/schema.py tests/karn/overwatch/test_schema.py
git commit -m "feat(scry): extend TuiSnapshot with best_runs leaderboard"
```

---

### Task 3: Export BestRunEntry from Package

**Files:**
- Modify: `src/esper/karn/overwatch/__init__.py`
- Modify: `tests/karn/overwatch/test_schema.py`

**Step 1: Write failing test for export**

```python
# tests/karn/overwatch/test_schema.py (modify TestPackageExports class)

    def test_best_run_entry_importable_from_package(self) -> None:
        """BestRunEntry is importable from overwatch package."""
        from esper.karn.overwatch import BestRunEntry

        assert BestRunEntry is not None
```

**Step 2: Run test to verify it fails**

Run: `PYTHONPATH=src uv run pytest tests/karn/overwatch/test_schema.py::TestPackageExports::test_best_run_entry_importable_from_package -v`

Expected: FAIL with `ImportError`

**Step 3: Update __init__.py exports**

Modify `src/esper/karn/overwatch/__init__.py`:

1. Add to imports:
```python
from esper.karn.overwatch.schema import (
    TuiSnapshot,
    EnvSummary,
    SlotChipState,
    TamiyoState,
    ConnectionStatus,
    DeviceVitals,
    FeedEvent,
    BestRunEntry,  # Add this line
)
```

2. Add to `__all__`:
```python
__all__ = [
    # Schema
    "TuiSnapshot",
    "EnvSummary",
    "SlotChipState",
    "TamiyoState",
    "ConnectionStatus",
    "DeviceVitals",
    "FeedEvent",
    "BestRunEntry",  # Add this line
    # ... rest unchanged
]
```

**Step 4: Run test to verify it passes**

Run: `PYTHONPATH=src uv run pytest tests/karn/overwatch/test_schema.py::TestPackageExports -v`

Expected: All export tests PASS

**Step 5: Commit**

```bash
git add src/esper/karn/overwatch/__init__.py tests/karn/overwatch/test_schema.py
git commit -m "feat(scry): export BestRunEntry from overwatch package"
```

---

## Stage 1: Server Skeleton

### Task 4: Create Scry Package Structure

**Files:**
- Create: `src/esper/karn/scry/__init__.py`
- Create: `tests/karn/scry/__init__.py`

**Step 1: Create package directories and init files**

```python
# src/esper/karn/scry/__init__.py
"""Esper Scry - WebSocket browser dashboard for remote training monitoring.

Provides the same monitoring capabilities as Overwatch TUI,
optimized for browser-based remote access.
"""

__all__: list[str] = []
```

```python
# tests/karn/scry/__init__.py
"""Tests for Esper Scry dashboard."""
```

**Step 2: Verify package imports**

Run: `PYTHONPATH=src python -c "from esper.karn import scry; print('OK')"`

Expected: `OK`

**Step 3: Commit**

```bash
git add src/esper/karn/scry/__init__.py tests/karn/scry/__init__.py
git commit -m "chore(scry): create package structure"
```

---

### Task 5: Implement Token Auth Module

**Files:**
- Create: `src/esper/karn/scry/auth.py`
- Create: `tests/karn/scry/test_auth.py`

**Step 1: Write failing tests for token auth**

```python
# tests/karn/scry/test_auth.py
"""Tests for Scry token authentication."""

from __future__ import annotations


class TestTokenAuth:
    """Tests for token generation and validation."""

    def test_generate_token_returns_hex_string(self) -> None:
        """generate_token returns a 32-character hex string."""
        from esper.karn.scry.auth import generate_token

        token = generate_token()

        assert isinstance(token, str)
        assert len(token) == 32
        # Verify it's valid hex
        int(token, 16)

    def test_generate_token_is_unique(self) -> None:
        """generate_token returns unique tokens."""
        from esper.karn.scry.auth import generate_token

        tokens = [generate_token() for _ in range(100)]
        unique_tokens = set(tokens)

        assert len(unique_tokens) == 100

    def test_validate_token_accepts_valid_token(self) -> None:
        """validate_token accepts the generated token."""
        from esper.karn.scry.auth import generate_token, validate_token

        token = generate_token()

        assert validate_token(token, token) is True

    def test_validate_token_rejects_invalid_token(self) -> None:
        """validate_token rejects wrong tokens."""
        from esper.karn.scry.auth import generate_token, validate_token

        valid_token = generate_token()
        invalid_token = "wrong" * 8

        assert validate_token(invalid_token, valid_token) is False

    def test_validate_token_rejects_empty_token(self) -> None:
        """validate_token rejects empty tokens."""
        from esper.karn.scry.auth import generate_token, validate_token

        valid_token = generate_token()

        assert validate_token("", valid_token) is False
        assert validate_token(None, valid_token) is False  # type: ignore[arg-type]

    def test_validate_token_timing_safe(self) -> None:
        """validate_token uses constant-time comparison."""
        from esper.karn.scry.auth import generate_token, validate_token
        import time

        valid_token = generate_token()
        # Token that differs in first character
        wrong_first = "0" + valid_token[1:]
        # Token that differs in last character
        wrong_last = valid_token[:-1] + "0"

        # Both should take roughly the same time (timing attack protection)
        times_first = []
        times_last = []

        for _ in range(100):
            start = time.perf_counter()
            validate_token(wrong_first, valid_token)
            times_first.append(time.perf_counter() - start)

            start = time.perf_counter()
            validate_token(wrong_last, valid_token)
            times_last.append(time.perf_counter() - start)

        avg_first = sum(times_first) / len(times_first)
        avg_last = sum(times_last) / len(times_last)

        # Should be within 50% of each other (timing attacks exploit larger differences)
        ratio = max(avg_first, avg_last) / min(avg_first, avg_last)
        assert ratio < 1.5, f"Timing difference too large: {ratio}"
```

**Step 2: Run tests to verify they fail**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/test_auth.py -v`

Expected: FAIL with `ModuleNotFoundError`

**Step 3: Implement auth module**

```python
# src/esper/karn/scry/auth.py
"""Scry Token Authentication.

Simple token-based auth for LAN security. Token is displayed on startup
and passed via query parameter: ws://host:8765/ws?token=abc123

Uses constant-time comparison to prevent timing attacks.
"""

from __future__ import annotations

import secrets
import hmac


def generate_token() -> str:
    """Generate a cryptographically secure 32-character hex token.

    Returns:
        Random 32-character hex string (128 bits of entropy)
    """
    return secrets.token_hex(16)


def validate_token(provided: str | None, expected: str) -> bool:
    """Validate a token using constant-time comparison.

    Args:
        provided: Token from request (may be None or empty)
        expected: The valid token to compare against

    Returns:
        True if tokens match, False otherwise
    """
    if not provided:
        return False

    # Use hmac.compare_digest for constant-time comparison
    # Prevents timing attacks that could leak token characters
    return hmac.compare_digest(provided, expected)
```

**Step 4: Run tests to verify they pass**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/test_auth.py -v`

Expected: All 6 tests PASS

**Step 5: Commit**

```bash
git add src/esper/karn/scry/auth.py tests/karn/scry/test_auth.py
git commit -m "feat(scry): add token authentication module"
```

---

### Task 6: Define WebSocket Protocol Messages

**Files:**
- Create: `src/esper/karn/scry/protocol.py`
- Create: `tests/karn/scry/test_protocol.py`

**Step 1: Write failing tests for protocol messages**

```python
# tests/karn/scry/test_protocol.py
"""Tests for Scry WebSocket protocol messages."""

from __future__ import annotations

import json


class TestServerMessage:
    """Tests for server-to-client messages."""

    def test_snapshot_message_creation(self) -> None:
        """SnapshotMessage wraps a TuiSnapshot."""
        from esper.karn.scry.protocol import ServerMessage, MessageType
        from esper.karn.overwatch import TuiSnapshot, ConnectionStatus, TamiyoState

        snap = TuiSnapshot(
            schema_version=1,
            captured_at="2025-12-18T12:00:00Z",
            connection=ConnectionStatus(True, 1000.0, 0.5),
            tamiyo=TamiyoState(),
        )

        msg = ServerMessage.snapshot(snap)

        assert msg.type == MessageType.SNAPSHOT
        assert msg.payload["schema_version"] == 1

    def test_server_message_to_json(self) -> None:
        """ServerMessage serializes to JSON string."""
        from esper.karn.scry.protocol import ServerMessage, MessageType
        from esper.karn.overwatch import TuiSnapshot, ConnectionStatus, TamiyoState

        snap = TuiSnapshot(
            schema_version=1,
            captured_at="2025-12-18T12:00:00Z",
            connection=ConnectionStatus(True, 1000.0, 0.5),
            tamiyo=TamiyoState(),
        )

        msg = ServerMessage.snapshot(snap)
        json_str = msg.to_json()
        parsed = json.loads(json_str)

        assert parsed["type"] == "snapshot"
        assert "payload" in parsed

    def test_error_message_creation(self) -> None:
        """ErrorMessage for server errors."""
        from esper.karn.scry.protocol import ServerMessage, MessageType

        msg = ServerMessage.error("Connection failed", code="CONN_FAILED")

        assert msg.type == MessageType.ERROR
        assert msg.payload["message"] == "Connection failed"
        assert msg.payload["code"] == "CONN_FAILED"

    def test_replay_status_message(self) -> None:
        """ReplayStatusMessage for playback state."""
        from esper.karn.scry.protocol import ServerMessage, MessageType

        msg = ServerMessage.replay_status(
            playing=True,
            position=45,
            total=100,
            speed=2.0,
        )

        assert msg.type == MessageType.REPLAY_STATUS
        assert msg.payload["playing"] is True
        assert msg.payload["position"] == 45


class TestClientMessage:
    """Tests for client-to-server messages."""

    def test_parse_replay_control(self) -> None:
        """Parse replay control message from client."""
        from esper.karn.scry.protocol import ClientMessage

        json_str = '{"type": "replay_control", "action": "pause"}'
        msg = ClientMessage.from_json(json_str)

        assert msg.type == "replay_control"
        assert msg.payload["action"] == "pause"

    def test_parse_replay_seek(self) -> None:
        """Parse replay seek message."""
        from esper.karn.scry.protocol import ClientMessage

        json_str = '{"type": "replay_control", "action": "seek", "position": 50}'
        msg = ClientMessage.from_json(json_str)

        assert msg.payload["action"] == "seek"
        assert msg.payload["position"] == 50

    def test_parse_invalid_json_raises(self) -> None:
        """Invalid JSON raises ValueError."""
        from esper.karn.scry.protocol import ClientMessage
        import pytest

        with pytest.raises(ValueError, match="Invalid JSON"):
            ClientMessage.from_json("not json")

    def test_parse_missing_type_raises(self) -> None:
        """Missing type field raises ValueError."""
        from esper.karn.scry.protocol import ClientMessage
        import pytest

        with pytest.raises(ValueError, match="Missing 'type' field"):
            ClientMessage.from_json('{"action": "pause"}')
```

**Step 2: Run tests to verify they fail**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/test_protocol.py -v`

Expected: FAIL with `ModuleNotFoundError`

**Step 3: Implement protocol module**

```python
# src/esper/karn/scry/protocol.py
"""Scry WebSocket Protocol.

Defines message types for server-client communication:
- ServerMessage: snapshot, replay_status, error
- ClientMessage: replay_control (play, pause, seek, speed)

Uses JSON serialization for simplicity and debuggability.
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from enum import Enum
from typing import Any, TYPE_CHECKING

if TYPE_CHECKING:
    from esper.karn.overwatch import TuiSnapshot


class MessageType(Enum):
    """Server message types."""
    SNAPSHOT = "snapshot"
    REPLAY_STATUS = "replay_status"
    ERROR = "error"


@dataclass
class ServerMessage:
    """Message from server to client.

    Factory methods create properly typed messages:
    - ServerMessage.snapshot(snap) - periodic TuiSnapshot
    - ServerMessage.replay_status(...) - playback state
    - ServerMessage.error(msg, code) - error notification
    """

    type: MessageType
    payload: dict[str, Any]

    @classmethod
    def snapshot(cls, snap: TuiSnapshot) -> ServerMessage:
        """Create a snapshot message."""
        return cls(
            type=MessageType.SNAPSHOT,
            payload=snap.to_dict(),
        )

    @classmethod
    def replay_status(
        cls,
        playing: bool,
        position: int,
        total: int,
        speed: float,
    ) -> ServerMessage:
        """Create a replay status message."""
        return cls(
            type=MessageType.REPLAY_STATUS,
            payload={
                "playing": playing,
                "position": position,
                "total": total,
                "speed": speed,
            },
        )

    @classmethod
    def error(cls, message: str, code: str = "UNKNOWN") -> ServerMessage:
        """Create an error message."""
        return cls(
            type=MessageType.ERROR,
            payload={
                "message": message,
                "code": code,
            },
        )

    def to_json(self) -> str:
        """Serialize to JSON string."""
        return json.dumps({
            "type": self.type.value,
            "payload": self.payload,
        }, separators=(",", ":"))


@dataclass
class ClientMessage:
    """Message from client to server.

    Currently supports:
    - replay_control: {action: play|pause|step|seek, position?, speed?}
    """

    type: str
    payload: dict[str, Any]

    @classmethod
    def from_json(cls, json_str: str) -> ClientMessage:
        """Parse client message from JSON.

        Args:
            json_str: Raw JSON string from WebSocket

        Returns:
            Parsed ClientMessage

        Raises:
            ValueError: If JSON is invalid or missing required fields
        """
        try:
            data = json.loads(json_str)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON: {e}") from e

        if "type" not in data:
            raise ValueError("Missing 'type' field in client message")

        return cls(
            type=data["type"],
            payload={k: v for k, v in data.items() if k != "type"},
        )
```

**Step 4: Run tests to verify they pass**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/test_protocol.py -v`

Expected: All 8 tests PASS

**Step 5: Commit**

```bash
git add src/esper/karn/scry/protocol.py tests/karn/scry/test_protocol.py
git commit -m "feat(scry): add WebSocket protocol message types"
```

---

### Task 7: Implement ScryServer Skeleton

**Files:**
- Create: `src/esper/karn/scry/server.py`
- Create: `tests/karn/scry/test_server.py`

**Step 1: Write failing tests for ScryServer**

```python
# tests/karn/scry/test_server.py
"""Tests for Scry WebSocket server."""

from __future__ import annotations

import asyncio
from pathlib import Path

import pytest

# Mark all tests in this module as async
pytestmark = pytest.mark.asyncio


class TestScryServer:
    """Tests for ScryServer HTTP and WebSocket handling."""

    async def test_server_starts_and_stops(self) -> None:
        """ScryServer can start and stop cleanly."""
        from esper.karn.scry.server import ScryServer

        server = ScryServer(port=0)  # port=0 picks random available port
        await server.start()

        assert server.is_running
        assert server.port > 0

        await server.stop()
        assert not server.is_running

    async def test_server_serves_index_html(self, tmp_path: Path) -> None:
        """ScryServer serves index.html at root."""
        from esper.karn.scry.server import ScryServer
        import aiohttp

        # Create minimal static dir with index.html
        static_dir = tmp_path / "static"
        static_dir.mkdir()
        (static_dir / "index.html").write_text("<html>Scry</html>")

        server = ScryServer(port=0, static_dir=static_dir)
        await server.start()

        try:
            async with aiohttp.ClientSession() as session:
                url = f"http://localhost:{server.port}/"
                async with session.get(url) as resp:
                    assert resp.status == 200
                    text = await resp.text()
                    assert "Scry" in text
        finally:
            await server.stop()

    async def test_server_requires_token_for_websocket(self) -> None:
        """WebSocket connection requires valid token."""
        from esper.karn.scry.server import ScryServer
        import aiohttp

        server = ScryServer(port=0)
        await server.start()

        try:
            async with aiohttp.ClientSession() as session:
                # Without token
                url = f"ws://localhost:{server.port}/ws"
                with pytest.raises(aiohttp.WSServerHandshakeError):
                    async with session.ws_connect(url):
                        pass

                # With wrong token
                url_wrong = f"ws://localhost:{server.port}/ws?token=wrong"
                with pytest.raises(aiohttp.WSServerHandshakeError):
                    async with session.ws_connect(url_wrong):
                        pass
        finally:
            await server.stop()

    async def test_server_accepts_valid_token(self) -> None:
        """WebSocket connection succeeds with valid token."""
        from esper.karn.scry.server import ScryServer
        import aiohttp

        server = ScryServer(port=0)
        await server.start()

        try:
            async with aiohttp.ClientSession() as session:
                url = f"ws://localhost:{server.port}/ws?token={server.token}"
                async with session.ws_connect(url) as ws:
                    assert not ws.closed
        finally:
            await server.stop()

    async def test_server_broadcasts_snapshot(self) -> None:
        """ScryServer broadcasts snapshots to connected clients."""
        from esper.karn.scry.server import ScryServer
        from esper.karn.overwatch import TuiSnapshot, ConnectionStatus, TamiyoState
        import aiohttp
        import json

        server = ScryServer(port=0)
        await server.start()

        try:
            async with aiohttp.ClientSession() as session:
                url = f"ws://localhost:{server.port}/ws?token={server.token}"
                async with session.ws_connect(url) as ws:
                    # Broadcast a snapshot
                    snap = TuiSnapshot(
                        schema_version=1,
                        captured_at="2025-12-18T12:00:00Z",
                        connection=ConnectionStatus(True, 1000.0, 0.5),
                        tamiyo=TamiyoState(),
                    )
                    await server.broadcast_snapshot(snap)

                    # Receive it
                    msg = await asyncio.wait_for(ws.receive_json(), timeout=2.0)
                    assert msg["type"] == "snapshot"
                    assert msg["payload"]["schema_version"] == 1
        finally:
            await server.stop()

    async def test_server_handles_multiple_clients(self) -> None:
        """ScryServer broadcasts to all connected clients."""
        from esper.karn.scry.server import ScryServer
        from esper.karn.overwatch import TuiSnapshot, ConnectionStatus, TamiyoState
        import aiohttp

        server = ScryServer(port=0)
        await server.start()

        try:
            async with aiohttp.ClientSession() as session:
                url = f"ws://localhost:{server.port}/ws?token={server.token}"

                async with session.ws_connect(url) as ws1, \
                           session.ws_connect(url) as ws2:

                    snap = TuiSnapshot(
                        schema_version=1,
                        captured_at="2025-12-18T12:00:00Z",
                        connection=ConnectionStatus(True, 1000.0, 0.5),
                        tamiyo=TamiyoState(),
                    )
                    await server.broadcast_snapshot(snap)

                    # Both clients should receive
                    msg1 = await asyncio.wait_for(ws1.receive_json(), timeout=2.0)
                    msg2 = await asyncio.wait_for(ws2.receive_json(), timeout=2.0)

                    assert msg1["type"] == "snapshot"
                    assert msg2["type"] == "snapshot"
        finally:
            await server.stop()

    async def test_server_no_auth_mode(self) -> None:
        """ScryServer can run without auth (--no-scry-auth)."""
        from esper.karn.scry.server import ScryServer
        import aiohttp

        server = ScryServer(port=0, require_auth=False)
        await server.start()

        try:
            async with aiohttp.ClientSession() as session:
                # Connect without token
                url = f"ws://localhost:{server.port}/ws"
                async with session.ws_connect(url) as ws:
                    assert not ws.closed
        finally:
            await server.stop()
```

**Step 2: Run tests to verify they fail**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/test_server.py -v`

Expected: FAIL with `ModuleNotFoundError`

**Step 3: Implement ScryServer**

```python
# src/esper/karn/scry/server.py
"""Scry WebSocket Server.

HTTP + WebSocket server for browser-based training monitoring.
Serves Vue SPA and streams TuiSnapshot to connected clients.

Usage:
    server = ScryServer(port=8765)
    await server.start()
    # ... during training ...
    await server.broadcast_snapshot(snapshot)
    # ... on shutdown ...
    await server.stop()
"""

from __future__ import annotations

import asyncio
import logging
from pathlib import Path
from typing import TYPE_CHECKING

from aiohttp import web, WSMsgType

from esper.karn.scry.auth import generate_token, validate_token
from esper.karn.scry.protocol import ServerMessage

if TYPE_CHECKING:
    from esper.karn.overwatch import TuiSnapshot

logger = logging.getLogger(__name__)


class ScryServer:
    """HTTP + WebSocket server for Scry dashboard.

    Attributes:
        port: Port number (0 = auto-select)
        token: Auth token displayed on startup
        is_running: Whether server is currently running
    """

    def __init__(
        self,
        port: int = 8765,
        static_dir: Path | None = None,
        require_auth: bool = True,
    ) -> None:
        """Initialize server.

        Args:
            port: Port to bind (0 for random available port)
            static_dir: Directory containing Vue SPA (index.html, etc.)
            require_auth: Whether to require token auth for WebSocket
        """
        self._port = port
        self._static_dir = static_dir
        self._require_auth = require_auth
        self._token = generate_token()

        self._app: web.Application | None = None
        self._runner: web.AppRunner | None = None
        self._site: web.TCPSite | None = None
        self._clients: set[web.WebSocketResponse] = set()
        self._running = False

    @property
    def port(self) -> int:
        """Actual port (may differ from requested if port=0)."""
        if self._site is not None:
            # Get actual bound port
            return self._site._server.sockets[0].getsockname()[1]  # type: ignore[union-attr]
        return self._port

    @property
    def token(self) -> str:
        """Auth token for WebSocket connections."""
        return self._token

    @property
    def is_running(self) -> bool:
        """Whether server is running."""
        return self._running

    async def start(self) -> None:
        """Start the HTTP/WebSocket server."""
        self._app = web.Application()
        self._app.router.add_get("/ws", self._websocket_handler)

        # Serve static files if directory provided
        if self._static_dir is not None:
            self._app.router.add_get("/", self._index_handler)
            self._app.router.add_static("/", self._static_dir)

        self._runner = web.AppRunner(self._app)
        await self._runner.setup()

        self._site = web.TCPSite(
            self._runner,
            host="0.0.0.0",
            port=self._port,
        )
        await self._site.start()
        self._running = True

        logger.info(f"Scry server started on port {self.port}")

    async def stop(self) -> None:
        """Stop the server and close all connections."""
        # Close all WebSocket connections
        for ws in list(self._clients):
            await ws.close()
        self._clients.clear()

        if self._runner is not None:
            await self._runner.cleanup()
            self._runner = None

        self._app = None
        self._site = None
        self._running = False

        logger.info("Scry server stopped")

    async def broadcast_snapshot(self, snapshot: TuiSnapshot) -> None:
        """Broadcast a snapshot to all connected clients.

        Args:
            snapshot: TuiSnapshot to send
        """
        if not self._clients:
            return

        msg = ServerMessage.snapshot(snapshot)
        json_str = msg.to_json()

        # Send to all clients, remove disconnected ones
        disconnected = []
        for ws in self._clients:
            try:
                await ws.send_str(json_str)
            except ConnectionResetError:
                disconnected.append(ws)

        for ws in disconnected:
            self._clients.discard(ws)

    async def _index_handler(self, request: web.Request) -> web.FileResponse:
        """Serve index.html for root path."""
        if self._static_dir is None:
            raise web.HTTPNotFound()
        index_path = self._static_dir / "index.html"
        return web.FileResponse(index_path)

    async def _websocket_handler(self, request: web.Request) -> web.WebSocketResponse:
        """Handle WebSocket connections."""
        # Auth check
        if self._require_auth:
            provided_token = request.query.get("token")
            if not validate_token(provided_token, self._token):
                raise web.HTTPForbidden(reason="Invalid or missing token")

        ws = web.WebSocketResponse()
        await ws.prepare(request)

        self._clients.add(ws)
        logger.info(f"Client connected (total: {len(self._clients)})")

        try:
            async for msg in ws:
                if msg.type == WSMsgType.TEXT:
                    # Handle client messages (replay controls, etc.)
                    # For now, just log them
                    logger.debug(f"Client message: {msg.data}")
                elif msg.type == WSMsgType.ERROR:
                    logger.warning(f"WebSocket error: {ws.exception()}")
        finally:
            self._clients.discard(ws)
            logger.info(f"Client disconnected (total: {len(self._clients)})")

        return ws
```

**Step 4: Run tests to verify they pass**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/test_server.py -v`

Expected: All 7 tests PASS

**Step 5: Commit**

```bash
git add src/esper/karn/scry/server.py tests/karn/scry/test_server.py
git commit -m "feat(scry): add ScryServer with HTTP and WebSocket support"
```

---

### Task 8: Update Scry Package Exports

**Files:**
- Modify: `src/esper/karn/scry/__init__.py`
- Create: `tests/karn/scry/test_exports.py`

**Step 1: Write failing test for exports**

```python
# tests/karn/scry/test_exports.py
"""Tests for Scry package exports."""

from __future__ import annotations


class TestScryExports:
    """Tests that public API is exported correctly."""

    def test_server_importable(self) -> None:
        """ScryServer is importable from scry package."""
        from esper.karn.scry import ScryServer

        assert ScryServer is not None

    def test_auth_functions_importable(self) -> None:
        """Auth functions are importable from scry package."""
        from esper.karn.scry import generate_token, validate_token

        assert generate_token is not None
        assert validate_token is not None

    def test_protocol_types_importable(self) -> None:
        """Protocol types are importable from scry package."""
        from esper.karn.scry import ServerMessage, ClientMessage, MessageType

        assert ServerMessage is not None
        assert ClientMessage is not None
        assert MessageType is not None
```

**Step 2: Run test to verify it fails**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/test_exports.py -v`

Expected: FAIL with `ImportError`

**Step 3: Update __init__.py**

```python
# src/esper/karn/scry/__init__.py
"""Esper Scry - WebSocket browser dashboard for remote training monitoring.

Provides the same monitoring capabilities as Overwatch TUI,
optimized for browser-based remote access.
"""

from esper.karn.scry.auth import generate_token, validate_token
from esper.karn.scry.protocol import ServerMessage, ClientMessage, MessageType
from esper.karn.scry.server import ScryServer

__all__ = [
    # Auth
    "generate_token",
    "validate_token",
    # Protocol
    "ServerMessage",
    "ClientMessage",
    "MessageType",
    # Server
    "ScryServer",
]
```

**Step 4: Run test to verify it passes**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/test_exports.py -v`

Expected: All 3 tests PASS

**Step 5: Commit**

```bash
git add src/esper/karn/scry/__init__.py tests/karn/scry/test_exports.py
git commit -m "feat(scry): export public API from package"
```

---

## Stage 2: Vue Scaffold

### Task 9: Create Vue Project with Vite

**Files:**
- Create: `src/esper/karn/scry/frontend/package.json`
- Create: `src/esper/karn/scry/frontend/vite.config.ts`
- Create: `src/esper/karn/scry/frontend/tsconfig.json`
- Create: `src/esper/karn/scry/frontend/index.html`

**Step 1: Create package.json**

```json
{
  "name": "esper-scry",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "lint": "eslint src --ext .ts,.vue"
  },
  "dependencies": {
    "vue": "^3.4.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.0",
    "@vue/test-utils": "^2.4.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "vitest": "^1.0.0",
    "vue-tsc": "^1.8.0"
  }
}
```

**Step 2: Create vite.config.ts**

```typescript
// src/esper/karn/scry/frontend/vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  build: {
    outDir: '../static',  // Build to Python-serveable directory
    emptyOutDir: true,
  },
  server: {
    proxy: {
      '/ws': {
        target: 'ws://localhost:8765',
        ws: true,
      },
    },
  },
})
```

**Step 3: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src/**/*.ts", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

**Step 4: Create tsconfig.node.json**

```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
```

**Step 5: Create index.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Esper Scry</title>
    <style>
      /* Dark ops base styles */
      :root {
        --bg-primary: #0d1117;
        --bg-secondary: #161b22;
        --text-primary: #c9d1d9;
        --text-secondary: #8b949e;
        --accent-green: #3fb950;
        --accent-yellow: #d29922;
        --accent-red: #f85149;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
        background-color: var(--bg-primary);
        color: var(--text-primary);
        min-height: 100vh;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

**Step 6: Commit**

```bash
git add src/esper/karn/scry/frontend/
git commit -m "chore(scry): create Vue project scaffold"
```

---

### Task 10: Create Vue App Entry Point

**Files:**
- Create: `src/esper/karn/scry/frontend/src/main.ts`
- Create: `src/esper/karn/scry/frontend/src/App.vue`
- Create: `src/esper/karn/scry/frontend/src/vite-env.d.ts`

**Step 1: Create vite-env.d.ts**

```typescript
// src/esper/karn/scry/frontend/src/vite-env.d.ts
/// <reference types="vite/client" />

declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}
```

**Step 2: Create main.ts**

```typescript
// src/esper/karn/scry/frontend/src/main.ts
import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
```

**Step 3: Create App.vue**

```vue
<!-- src/esper/karn/scry/frontend/src/App.vue -->
<script setup lang="ts">
import { ref } from 'vue'

// Placeholder - will be replaced with useScrySocket
const connectionStatus = ref<'connecting' | 'connected' | 'disconnected'>('connecting')
const lastSnapshot = ref<object | null>(null)
</script>

<template>
  <div class="scry-app">
    <header class="scry-header">
      <h1>ESPER SCRY</h1>
      <span class="connection-status" :class="connectionStatus">
        {{ connectionStatus }}
      </span>
    </header>

    <main class="scry-main">
      <div class="snapshot-debug">
        <h2>Snapshot Data</h2>
        <pre v-if="lastSnapshot">{{ JSON.stringify(lastSnapshot, null, 2) }}</pre>
        <p v-else class="no-data">Waiting for snapshot...</p>
      </div>
    </main>
  </div>
</template>

<style scoped>
.scry-app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.scry-header {
  background: var(--bg-secondary);
  padding: 1rem 2rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #30363d;
}

.scry-header h1 {
  font-size: 1.25rem;
  font-weight: 600;
  letter-spacing: 0.05em;
}

.connection-status {
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  font-size: 0.75rem;
  text-transform: uppercase;
  font-weight: 500;
}

.connection-status.connecting {
  background: var(--accent-yellow);
  color: #000;
}

.connection-status.connected {
  background: var(--accent-green);
  color: #000;
}

.connection-status.disconnected {
  background: var(--accent-red);
  color: #fff;
}

.scry-main {
  flex: 1;
  padding: 2rem;
}

.snapshot-debug {
  background: var(--bg-secondary);
  border-radius: 0.5rem;
  padding: 1.5rem;
}

.snapshot-debug h2 {
  font-size: 0.875rem;
  color: var(--text-secondary);
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.snapshot-debug pre {
  font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
  font-size: 0.75rem;
  line-height: 1.5;
  overflow: auto;
  max-height: 70vh;
  color: var(--text-primary);
}

.no-data {
  color: var(--text-secondary);
  font-style: italic;
}
</style>
```

**Step 4: Commit**

```bash
git add src/esper/karn/scry/frontend/src/
git commit -m "feat(scry): add Vue app entry point and shell"
```

---

### Task 11: Implement useScrySocket Composable

**Files:**
- Create: `src/esper/karn/scry/frontend/src/composables/useScrySocket.ts`
- Create: `src/esper/karn/scry/frontend/src/types/snapshot.ts`

**Step 1: Create TypeScript types for TuiSnapshot**

```typescript
// src/esper/karn/scry/frontend/src/types/snapshot.ts
/**
 * TypeScript types matching Python TuiSnapshot schema.
 * Keep in sync with src/esper/karn/overwatch/schema.py
 */

export interface SlotChipState {
  slot_id: string
  stage: string
  blueprint_id: string
  alpha: number
  epochs_in_stage: number
  epochs_total: number
  gate_last: string | null
  gate_passed: boolean | null
}

export interface EnvSummary {
  env_id: number
  device_id: number
  status: 'OK' | 'INFO' | 'WARN' | 'CRIT'
  throughput_fps: number
  step_time_ms: number
  reward_last: number
  task_metric: number
  task_metric_delta: number
  slots: Record<string, SlotChipState>
  anomaly_score: number
  anomaly_reasons: string[]
  last_update_ts: number
}

export interface TamiyoState {
  action_counts: Record<string, number>
  recent_actions: string[]
  confidence_mean: number
  confidence_min: number
  confidence_max: number
  confidence_history: number[]
  exploration_pct: number
  kl_divergence: number
  entropy: number
  clip_fraction: number
  explained_variance: number
  grad_norm: number
  learning_rate: number
  kl_trend: number
  entropy_trend: number
  ev_trend: number
  entropy_collapsed: boolean
  ev_warning: boolean
}

export interface ConnectionStatus {
  connected: boolean
  last_event_ts: number
  staleness_s: number
}

export interface DeviceVitals {
  device_id: number
  name: string
  utilization_pct: number
  memory_used_gb: number
  memory_total_gb: number
  temperature_c: number
}

export interface FeedEvent {
  timestamp: string
  event_type: string
  env_id: number | null
  message: string
}

export interface BestRunEntry {
  env_id: number
  best_accuracy: number
  cumulative_reward: number
  param_delta: number
  slot_configs: Record<string, string>
  achieved_at_episode: number
  dismissed: boolean
}

export interface TuiSnapshot {
  schema_version: number
  captured_at: string
  connection: ConnectionStatus
  tamiyo: TamiyoState
  run_id: string
  task_name: string
  episode: number
  batch: number
  best_metric: number
  runtime_s: number
  devices: DeviceVitals[]
  flight_board: EnvSummary[]
  event_feed: FeedEvent[]
  envs_ok: number
  envs_warn: number
  envs_crit: number
  best_runs: BestRunEntry[]
}

export interface ServerMessage {
  type: 'snapshot' | 'replay_status' | 'error'
  payload: TuiSnapshot | ReplayStatus | ErrorPayload
}

export interface ReplayStatus {
  playing: boolean
  position: number
  total: number
  speed: number
}

export interface ErrorPayload {
  message: string
  code: string
}
```

**Step 2: Create useScrySocket composable**

```typescript
// src/esper/karn/scry/frontend/src/composables/useScrySocket.ts
import { ref, computed, onMounted, onUnmounted } from 'vue'
import type { TuiSnapshot, ServerMessage } from '../types/snapshot'

export type ConnectionState = 'connecting' | 'connected' | 'reconnecting' | 'disconnected'

export interface UseScrySocketOptions {
  url?: string
  token?: string
  reconnectInterval?: number
  maxReconnectAttempts?: number
}

export function useScrySocket(options: UseScrySocketOptions = {}) {
  const {
    url = getDefaultUrl(),
    token = getTokenFromUrl(),
    reconnectInterval = 2000,
    maxReconnectAttempts = 10,
  } = options

  const connectionState = ref<ConnectionState>('connecting')
  const snapshot = ref<TuiSnapshot | null>(null)
  const error = ref<string | null>(null)
  const reconnectAttempts = ref(0)

  let ws: WebSocket | null = null
  let reconnectTimer: ReturnType<typeof setTimeout> | null = null

  const isConnected = computed(() => connectionState.value === 'connected')

  function connect() {
    if (ws?.readyState === WebSocket.OPEN) {
      return
    }

    const wsUrl = token ? `${url}?token=${token}` : url
    connectionState.value = reconnectAttempts.value > 0 ? 'reconnecting' : 'connecting'
    error.value = null

    try {
      ws = new WebSocket(wsUrl)

      ws.onopen = () => {
        connectionState.value = 'connected'
        reconnectAttempts.value = 0
        console.log('[Scry] Connected to server')
      }

      ws.onmessage = (event) => {
        try {
          const msg: ServerMessage = JSON.parse(event.data)
          handleMessage(msg)
        } catch (e) {
          console.error('[Scry] Failed to parse message:', e)
        }
      }

      ws.onclose = (event) => {
        console.log('[Scry] Connection closed:', event.code, event.reason)
        handleDisconnect()
      }

      ws.onerror = (event) => {
        console.error('[Scry] WebSocket error:', event)
        error.value = 'Connection error'
      }
    } catch (e) {
      console.error('[Scry] Failed to create WebSocket:', e)
      handleDisconnect()
    }
  }

  function handleMessage(msg: ServerMessage) {
    switch (msg.type) {
      case 'snapshot':
        snapshot.value = msg.payload as TuiSnapshot
        break
      case 'error':
        error.value = (msg.payload as { message: string }).message
        break
      case 'replay_status':
        // Will be handled by useReplayControls
        break
    }
  }

  function handleDisconnect() {
    ws = null

    if (reconnectAttempts.value < maxReconnectAttempts) {
      connectionState.value = 'reconnecting'
      reconnectAttempts.value++

      const delay = reconnectInterval * Math.min(reconnectAttempts.value, 5)
      console.log(`[Scry] Reconnecting in ${delay}ms (attempt ${reconnectAttempts.value})`)

      reconnectTimer = setTimeout(connect, delay)
    } else {
      connectionState.value = 'disconnected'
      error.value = 'Max reconnection attempts reached'
    }
  }

  function disconnect() {
    if (reconnectTimer) {
      clearTimeout(reconnectTimer)
      reconnectTimer = null
    }
    if (ws) {
      ws.close()
      ws = null
    }
    connectionState.value = 'disconnected'
  }

  function send(message: object) {
    if (ws?.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message))
    }
  }

  onMounted(() => {
    connect()
  })

  onUnmounted(() => {
    disconnect()
  })

  return {
    connectionState,
    snapshot,
    error,
    isConnected,
    reconnectAttempts,
    connect,
    disconnect,
    send,
  }
}

// Helper functions
function getDefaultUrl(): string {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
  const host = window.location.host
  return `${protocol}//${host}/ws`
}

function getTokenFromUrl(): string | undefined {
  const params = new URLSearchParams(window.location.search)
  return params.get('token') ?? undefined
}
```

**Step 3: Commit**

```bash
git add src/esper/karn/scry/frontend/src/composables/ src/esper/karn/scry/frontend/src/types/
git commit -m "feat(scry): add useScrySocket composable and TypeScript types"
```

---

### Task 12: Wire Up App.vue with useScrySocket

**Files:**
- Modify: `src/esper/karn/scry/frontend/src/App.vue`

**Step 1: Update App.vue to use useScrySocket**

```vue
<!-- src/esper/karn/scry/frontend/src/App.vue -->
<script setup lang="ts">
import { computed } from 'vue'
import { useScrySocket } from './composables/useScrySocket'

const {
  connectionState,
  snapshot,
  error,
  reconnectAttempts,
} = useScrySocket()

const statusClass = computed(() => {
  switch (connectionState.value) {
    case 'connected': return 'connected'
    case 'connecting':
    case 'reconnecting': return 'connecting'
    default: return 'disconnected'
  }
})

const statusText = computed(() => {
  if (connectionState.value === 'reconnecting') {
    return `reconnecting (${reconnectAttempts.value})`
  }
  return connectionState.value
})
</script>

<template>
  <div class="scry-app">
    <header class="scry-header">
      <h1>ESPER SCRY</h1>
      <div class="header-right">
        <span v-if="error" class="error-badge">{{ error }}</span>
        <span class="connection-status" :class="statusClass">
          {{ statusText }}
        </span>
      </div>
    </header>

    <main class="scry-main">
      <div class="snapshot-debug">
        <h2>Snapshot Data (Debug View)</h2>
        <template v-if="snapshot">
          <div class="snapshot-meta">
            <span>Schema v{{ snapshot.schema_version }}</span>
            <span>{{ snapshot.task_name }}</span>
            <span>Episode {{ snapshot.episode }}</span>
            <span>Batch {{ snapshot.batch }}</span>
          </div>
          <pre>{{ JSON.stringify(snapshot, null, 2) }}</pre>
        </template>
        <p v-else class="no-data">
          <template v-if="connectionState === 'connecting'">
            Connecting to server...
          </template>
          <template v-else-if="connectionState === 'reconnecting'">
            Reconnecting (attempt {{ reconnectAttempts }})...
          </template>
          <template v-else>
            Waiting for snapshot data...
          </template>
        </p>
      </div>
    </main>
  </div>
</template>

<style scoped>
.scry-app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.scry-header {
  background: var(--bg-secondary);
  padding: 1rem 2rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #30363d;
}

.scry-header h1 {
  font-size: 1.25rem;
  font-weight: 600;
  letter-spacing: 0.05em;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.error-badge {
  background: var(--accent-red);
  color: #fff;
  padding: 0.25rem 0.75rem;
  border-radius: 0.25rem;
  font-size: 0.75rem;
}

.connection-status {
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  font-size: 0.75rem;
  text-transform: uppercase;
  font-weight: 500;
}

.connection-status.connecting {
  background: var(--accent-yellow);
  color: #000;
}

.connection-status.connected {
  background: var(--accent-green);
  color: #000;
}

.connection-status.disconnected {
  background: var(--accent-red);
  color: #fff;
}

.scry-main {
  flex: 1;
  padding: 2rem;
  overflow: auto;
}

.snapshot-debug {
  background: var(--bg-secondary);
  border-radius: 0.5rem;
  padding: 1.5rem;
}

.snapshot-debug h2 {
  font-size: 0.875rem;
  color: var(--text-secondary);
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.snapshot-meta {
  display: flex;
  gap: 1.5rem;
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #30363d;
  font-size: 0.875rem;
  color: var(--text-secondary);
}

.snapshot-debug pre {
  font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
  font-size: 0.75rem;
  line-height: 1.5;
  overflow: auto;
  max-height: 70vh;
  color: var(--text-primary);
}

.no-data {
  color: var(--text-secondary);
  font-style: italic;
}
</style>
```

**Step 2: Commit**

```bash
git add src/esper/karn/scry/frontend/src/App.vue
git commit -m "feat(scry): wire App.vue with useScrySocket"
```

---

### Task 13: Run Full Test Suite

**Step 1: Run all Scry and Overwatch schema tests**

Run: `PYTHONPATH=src uv run pytest tests/karn/scry/ tests/karn/overwatch/test_schema.py -v`

Expected: All tests PASS

**Step 2: Run linting on new code**

Run: `uv run ruff check src/esper/karn/scry/`

Expected: No errors

**Step 3: Verify imports work**

Run: `PYTHONPATH=src python -c "from esper.karn.scry import ScryServer, generate_token; from esper.karn.overwatch import TuiSnapshot, BestRunEntry; print('OK')"`

Expected: `OK`

**Step 4: Final commit**

```bash
git add -A
git status
git commit -m "chore(scry): Stage 0.5-2 complete - schema + server + Vue scaffold"
```

---

## Verification Checklist

- [ ] `BestRunEntry` schema added and exported
- [ ] `TuiSnapshot.best_runs` field added (backwards-compatible)
- [ ] `ScryServer` serves static files and WebSocket
- [ ] Token auth works (accepts valid, rejects invalid)
- [ ] Server broadcasts snapshots to all clients
- [ ] Vue project created with Vite
- [ ] `useScrySocket` composable connects and receives snapshots
- [ ] TypeScript types match Python schema
- [ ] All tests pass
- [ ] Linting passes

---

## Files Created/Modified

```
src/esper/karn/
├── overwatch/
│   ├── __init__.py          # Modified: export BestRunEntry
│   └── schema.py            # Modified: add BestRunEntry, TuiSnapshot.best_runs
│
└── scry/
    ├── __init__.py          # Created: package exports
    ├── auth.py              # Created: token generation/validation
    ├── protocol.py          # Created: WebSocket message types
    ├── server.py            # Created: HTTP + WebSocket server
    └── frontend/
        ├── package.json
        ├── vite.config.ts
        ├── tsconfig.json
        ├── tsconfig.node.json
        ├── index.html
        └── src/
            ├── main.ts
            ├── App.vue
            ├── vite-env.d.ts
            ├── composables/
            │   └── useScrySocket.ts
            └── types/
                └── snapshot.ts

tests/karn/
├── overwatch/
│   └── test_schema.py       # Modified: add BestRunEntry tests
│
└── scry/
    ├── __init__.py          # Created
    ├── test_auth.py         # Created
    ├── test_protocol.py     # Created
    ├── test_server.py       # Created
    └── test_exports.py      # Created
```

---

## Next Stages

After Stages 0.5-2 are complete:

| Stage | Name | Description |
|-------|------|-------------|
| **3** | Layout Shell | 5-region grid layout with placeholder components |
| **4** | Flight Board | EnvCard, SlotChip, pinning, anomaly sorting |
| **5** | Tamiyo + Best Runs | TamiyoStrip, sparklines, leaderboard |
| **6** | Header + Detail | Connection status, GPU vitals, "why flagged" |
| **7** | Event Feed | Scrolling log with filtering |
| **8** | Replay Controls | Play/pause/step/speed, scrubber |
| **9** | Live Integration | Wire aggregator to Nissa, `--scry` CLI flag |

Each stage will have its own detailed implementation plan.
