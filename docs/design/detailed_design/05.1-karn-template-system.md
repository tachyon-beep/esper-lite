# Karn - Template System (Phase 1 Implementation)

## Document Metadata

| Field | Value |
|-------|-------|
| **Parent Document** | [05-karn-unified-design.md](05-karn-unified-design.md) |
| **Component Type** | Template-Based Generation System |
| **Version** | 3.1 |
| **Status** | PRODUCTION |
| **Implementation** | Current Phase 1 System |

## Overview

The Template System implements Karn's Phase 1 blueprint generation capability using hardcoded templates with intelligent mutations. This component provides the current production-ready implementation with 50 blueprints across three safety tiers, Leyline (shared contracts) integration, and field report learning to prepare data for future Phase 2 neural generation.

The system represents the C-014 Conclave's consensus approach: deploy proven templates immediately while collecting field data for neural generation. All blueprints undergo mandatory Urabrask validation, with adversarial blueprints (BP043-BP050) strictly quarantined for Tamiyo training only - "essential to learn what doesn't work" as the conclave noted.

Key characteristics:
- **50 Blueprint Library**: Production (35), Experimental (7), Adversarial (8) mapped to Jace's curriculum
- **Three-Tier Safety**: Risk-based isolation with circuit breaker protection
- **Leyline Integration**: Performance-first shared contracts with 20-30% overhead reduction
- **Learning System**: Reward models and pattern recognition preparing for Phase 2

## Technical Design

### Architecture

```
KarnBlueprintGenerator
├── CircuitBreaker (failure_threshold=3)
├── ConservativeMode (fallback templates)
├── MemoryManager (TTL cleanup)
└── Components:
    ├── TemplateSelector
    │   └── Urza Integration
    ├── MutationEngine
    │   └── Risk Assessment
    ├── ValidationPipeline
    │   └── Urabrask Integration
    └── RewardModel
        └── Field Report Processing
```

### Core Abstractions

**KarnBlueprintGenerator**
```python
from time import perf_counter
from typing import Dict, Any, Optional

# Import from Leyline (shared contracts)
from esper.leyline.contracts import (
    SystemStatePacket,
    AdaptationCommand,
    EventEnvelope,
    HardwareContext,
    MessagePriority,
    SeedLifecycleStage
)
from esper.leyline.version import SchemaVersion

class KarnBlueprintGenerator:
    """Current template-based blueprint generation with Leyline integration"""

    def __init__(self):
        # Circuit breaker instead of assert statements
        self.circuit_breaker = CircuitBreaker(
            failure_threshold=3,
            recovery_timeout_ms=30000
        )
        self.conservative_mode = ConservativeMode()
        self.memory_manager = MemoryManager()
        self.metrics = KarnMetrics()

    def generate_blueprint(self, context: Dict[str, Any]) -> BlueprintIR:
        """Generate blueprint with Leyline integration"""
        start_time = perf_counter()

        try:
            # Circuit breaker check instead of bare execution
            if not self.circuit_breaker.is_closed():
                return self.conservative_mode.get_safe_blueprint(context)

            # Decision-based generation (using Leyline AdaptationCommand)
            if "adaptation_command" in context:
                return self._generate_from_adaptation_command(
                    command=context["adaptation_command"],
                    system_state=context.get("system_state")
                )

            # Template-based generation
            templates = self.get_mutation_templates()  # Query Urza
            base_template = self._select_best_template(
                target_task=context.get("target_task"),
                performance_targets=context.get("performance_targets"),
                constraints=context.get("constraints")
            )

            # Apply mutations
            blueprint = self._synthesize_from_template(
                template=base_template,
                target_task=context.get("target_task"),
                performance_targets=context.get("performance_targets"),
                constraints=context.get("constraints")
            )

            # Enhanced validation before return
            if not self._validate_blueprint_with_urabrask(blueprint):
                return self.conservative_mode.get_safe_blueprint(context)

            return blueprint

        except Exception as e:
            # Circuit breaker failure handling
            self.circuit_breaker.record_failure()
            self.metrics.generation_failure.inc()
            return self.conservative_mode.get_safe_blueprint(context)

        finally:
            # Timing budget with circuit breaker
            duration_ms = (perf_counter() - start_time) * 1000
            if duration_ms > 400:  # 400ms generation budget (improved with Leyline)
                self.metrics.generation_overrun_ms.observe(duration_ms)
                self._trigger_conservative_mode("generation_timeout", duration_ms)
            else:
                self.metrics.generation_duration_ms.observe(duration_ms)
```

**ThreeTierSafetyArchitecture**
- Purpose: Isolates blueprints by risk level with mandatory validation
- Key Methods: `assign_tier`, `validate_tier_assignment`, `enforce_quarantine`
- State Management: Risk budget tracking with circuit breaker protection

### Algorithms

#### Phase 1 Blueprint Library (50 Blueprints)

**Purpose**: Provide comprehensive blueprint coverage across all curriculum stages

**Implementation**:
```python
def generate_phase1_blueprints(self) -> Dict[str, List[BlueprintIR]]:
    """Generate 50 blueprints with three-tier safety architecture and Leyline validation"""

    blueprints = {
        "production": [],      # BP001-BP035: Risk 0.0-0.5
        "experimental": [],    # BP036-BP042: Risk 0.5-0.8
        "adversarial": []      # BP043-BP050: Risk 0.8-1.0 (QUARANTINED)
    }

    # Stage 0-1: Basic/Simple (BP001-BP014) - Production Tier
    blueprints["production"].extend([
        BlueprintIR("BP001", "identity_passthrough", risk=0.0, stage=0),
        BlueprintIR("BP002", "linear_projection", risk=0.1, stage=0),
        BlueprintIR("BP003", "layer_norm_basic", risk=0.1, stage=0),
        BlueprintIR("BP004", "dropout_light", risk=0.2, stage=0),
        BlueprintIR("BP005", "relu_activation", risk=0.1, stage=0),
        BlueprintIR("BP006", "batch_norm_1d", risk=0.2, stage=0),
        BlueprintIR("BP007", "pooling_max", risk=0.2, stage=0),
        BlueprintIR("BP008", "skip_connection", risk=0.2, stage=1),
        BlueprintIR("BP009", "residual_block", risk=0.3, stage=1),
        BlueprintIR("BP010", "concat_fusion", risk=0.3, stage=1),
        BlueprintIR("BP011", "gelu_activation", risk=0.2, stage=1),
        BlueprintIR("BP012", "layer_scaling", risk=0.3, stage=1),
        BlueprintIR("BP013", "grouped_conv", risk=0.4, stage=1),
        BlueprintIR("BP014", "highway_gate", risk=0.4, stage=1)
    ])

    # Stage 2-4: Moderate/Complex/Advanced (BP015-BP035) - Production Tier
    blueprints["production"].extend([
        BlueprintIR("BP015", "depthwise_separable", risk=0.4, stage=2),
        BlueprintIR("BP016", "squeeze_excitation", risk=0.4, stage=2),
        BlueprintIR("BP017", "channel_attention", risk=0.4, stage=2),
        BlueprintIR("BP018", "spatial_attention", risk=0.4, stage=2),
        BlueprintIR("BP019", "cross_attention", risk=0.5, stage=2),
        BlueprintIR("BP020", "attention_single_head", risk=0.5, stage=2),
        BlueprintIR("BP021", "feedforward_gated", risk=0.5, stage=2),
        BlueprintIR("BP022", "multi_head_attention_4", risk=0.5, stage=3),
        BlueprintIR("BP023", "transformer_block", risk=0.5, stage=3),
        BlueprintIR("BP024", "conv_transformer", risk=0.5, stage=3),
        BlueprintIR("BP025", "dynamic_conv", risk=0.5, stage=3),
        BlueprintIR("BP026", "adaptive_pooling", risk=0.5, stage=3),
        BlueprintIR("BP027", "feature_pyramid", risk=0.5, stage=3),
        BlueprintIR("BP028", "dense_connection", risk=0.5, stage=3),
        BlueprintIR("BP029", "multi_head_attention_8", risk=0.5, stage=4),
        BlueprintIR("BP030", "graph_attention", risk=0.5, stage=4),
        BlueprintIR("BP031", "temporal_conv", risk=0.5, stage=4),
        BlueprintIR("BP032", "dilated_conv", risk=0.5, stage=4),
        BlueprintIR("BP033", "deformable_conv", risk=0.5, stage=4),
        BlueprintIR("BP034", "non_local_block", risk=0.5, stage=4),
        BlueprintIR("BP035", "learned_positional", risk=0.5, stage=4)
    ])

    # Stage 5: Expert (BP036-BP042) - Experimental Tier
    blueprints["experimental"].extend([
        BlueprintIR("BP036", "mixture_of_experts_4", risk=0.7, stage=5),
        BlueprintIR("BP037", "hierarchical_attention", risk=0.7, stage=5),
        BlueprintIR("BP038", "memory_augmented", risk=0.8, stage=5),
        BlueprintIR("BP039", "neural_ode_block", risk=0.8, stage=5),
        BlueprintIR("BP040", "differentiable_nas", risk=0.8, stage=5),
        BlueprintIR("BP041", "meta_learning_layer", risk=0.8, stage=5),
        BlueprintIR("BP042", "recursive_processing", risk=0.8, stage=5)
    ])

    # Stage 6: Adversarial (BP043-BP050) - Training Only, NEVER Production
    blueprints["adversarial"].extend([
        BlueprintIR("BP043", "exploding_gradient", risk=0.9, stage=6),
        BlueprintIR("BP044", "vanishing_gradient", risk=0.9, stage=6),
        BlueprintIR("BP045", "nan_injection", risk=1.0, stage=6),
        BlueprintIR("BP046", "infinite_loop", risk=1.0, stage=6),
        BlueprintIR("BP047", "memory_leak", risk=1.0, stage=6),
        BlueprintIR("BP048", "deadlock_pattern", risk=1.0, stage=6),
        BlueprintIR("BP049", "race_condition", risk=0.9, stage=6),
        BlueprintIR("BP050", "adversarial_noise", risk=0.9, stage=6)
    ])

    # Enhanced validation for ALL blueprints with Leyline
    for tier, blueprint_list in blueprints.items():
        for blueprint in blueprint_list:
            self._apply_leyline_validation(blueprint, tier)

    return blueprints

def _apply_leyline_validation(self, blueprint: BlueprintIR, tier: str) -> None:
    """Apply Leyline validation to each blueprint"""
    # Add Leyline metadata
    blueprint.leyline_compliant = True
    blueprint.schema_version = SchemaVersion.get_version()
    blueprint.validation_tier = tier
    blueprint.urabrask_required = True if tier != "production" else False
    blueprint.quarantine_only = True if tier == "adversarial" else False

    # Safety validation pipeline
    if not self.validation_pipeline.validate_blueprint(blueprint):
        raise ValueError(f"Blueprint {blueprint.id} failed Leyline validation")
```

#### Three-Tier Safety Architecture

**Purpose**: Isolate blueprints by risk level with circuit breaker protection

**Implementation**:
```python
class ThreeTierSafetyArchitecture:
    """Isolate blueprints by risk level with Leyline integration"""

    def __init__(self):
        self.circuit_breaker = CircuitBreaker(failure_threshold=3)
        self.validation_pipeline = EnhancedValidationPipeline()

        self.tiers = {
            "production": {       # BP001-BP035
                "risk_range": (0.0, 0.5),
                "storage": "urza_production",
                "validation": "standard_urabrask",
                "oona_topic": "blueprints.production",
                "circuit_breaker_threshold": 5,  # Higher tolerance for production
                "leyline_message_priority": MessagePriority.PRIORITY_NORMAL
            },
            "experimental": {     # BP036-BP042
                "risk_range": (0.5, 0.8),
                "storage": "urza_experimental",
                "validation": "enhanced_urabrask",
                "oona_topic": "blueprints.experimental",
                "circuit_breaker_threshold": 3,  # Standard threshold
                "leyline_message_priority": MessagePriority.PRIORITY_HIGH
            },
            "adversarial": {      # BP043-BP050
                "risk_range": (0.8, 1.0),
                "storage": "quarantine_only",  # NEVER in Urza
                "validation": "isolated_analysis",
                "oona_topic": "blueprints.adversarial.training_only",
                "circuit_breaker_threshold": 1,  # Immediate quarantine
                "leyline_message_priority": MessagePriority.PRIORITY_CRITICAL
            }
        }

    def assign_tier(self, blueprint: BlueprintIR) -> str:
        """Assign blueprint to appropriate safety tier with Leyline validation"""
        # Circuit breaker check before tier assignment
        if not self.circuit_breaker.is_closed():
            # In degraded mode, only allow production tier
            if blueprint.risk_score <= 0.3:  # Conservative threshold
                return "production"
            else:
                raise ValueError("Cannot assign high-risk blueprint in degraded mode")

        for tier_name, config in self.tiers.items():
            min_risk, max_risk = config["risk_range"]
            if min_risk <= blueprint.risk_score <= max_risk:
                # Enhanced validation before tier assignment
                if self.validation_pipeline.validate_tier_assignment(blueprint, tier_name):
                    return tier_name
                else:
                    # Force to quarantine if validation fails
                    return "adversarial"

        # Fallback to quarantine for unknown risk
        return "adversarial"
```

#### Decision-Based Generation

**Purpose**: Generate targeted blueprints based on Tamiyo's strategic decisions

**Implementation**:
```python
def _generate_from_adaptation_command(
    self,
    command: AdaptationCommand,
    system_state: SystemStatePacket
) -> BlueprintIR:
    """Generate blueprint from Leyline AdaptationCommand"""
    start_time = perf_counter()

    try:
        # Circuit breaker check
        if not self.circuit_breaker.is_closed():
            return self.conservative_mode.get_safe_blueprint({
                "adaptation_command": command,
                "system_state": system_state
            })

        # Extract command details from Leyline AdaptationCommand
        if command.command_type == CommandType.COMMAND_SEED:
            seed_command = command.seed_command
            strategy = seed_command.operation
        else:
            # Handle other command types
            strategy = self._extract_strategy_from_command(command)

        # Use SystemStatePacket for context
        telemetry = {
            "validation_accuracy": system_state.validation_accuracy,
            "validation_loss": system_state.validation_loss,
            "training_metrics": dict(system_state.training_metrics),  # Native map<> support
            "hardware_context": system_state.hardware_context
        }

        if strategy == SeedOperation.SEED_OP_START_TRAINING:
            # Severe underfitting - triple capacity
            blueprint = BlueprintIR(
                operation_type="width_expansion",
                parameters={
                    "expansion_factor": 3.0,
                    "add_batch_norm": True,
                    "add_dropout": 0.3
                },
                estimated_performance_impact=0.25,
                risk_assessment=0.35
            )

        elif strategy == SeedOperation.SEED_OP_START_GRAFTING:
            # Fix specific bottlenecks
            blueprint = BlueprintIR(
                operation_type="layer_addition",
                target_layer_pattern=".*bottleneck.*",
                parameters={
                    "layer_type": "linear",
                    "hidden_dim": 64,
                    "activation": "gelu",
                    "use_layer_norm": True
                },
                estimated_performance_impact=0.15,
                risk_assessment=0.25
            )

        elif self._detect_dead_neurons(telemetry) > 0.4:
            # High dead neuron ratio - activation fix
            blueprint = BlueprintIR(
                operation_type="activation_swap",
                parameters={
                    "new_activation": "swish",
                    "learnable_beta": True
                },
                estimated_performance_impact=0.18,
                risk_assessment=0.2
            )

        else:
            # Default improvement - skip connections
            blueprint = self._default_improvement_blueprint()

        # Mandatory Urabrask validation for all generated blueprints
        if not self.validation_pipeline.validate_with_urabrask(blueprint):
            return self.conservative_mode.get_safe_blueprint({
                "adaptation_command": command,
                "system_state": system_state
            })

        return blueprint

    except Exception as e:
        # Circuit breaker failure handling
        self.circuit_breaker.record_failure()
        return self.conservative_mode.get_safe_blueprint({
            "adaptation_command": command,
            "system_state": system_state
        })

    finally:
        # Timing budget monitoring
        duration_ms = (perf_counter() - start_time) * 1000
        if duration_ms > 150:  # 150ms decision budget (improved with Leyline)
            self._trigger_conservative_mode("decision_timeout", duration_ms)
```

## Integration Points

### Internal Integration

| Component | Interface | Data Flow |
|-----------|-----------|-----------|
| Urza Library | `query_blueprints`, `store_blueprint_async` | Templates in, blueprints out |
| Urabrask Validator | `validate_blueprint`, `validate_with_urabrask_async` | Blueprint validation results |
| Conservative Mode | `get_safe_blueprint`, `get_minimal_risk_blueprint` | Fallback blueprints |
| Circuit Breaker | `is_closed`, `record_failure`, `get_state` | System health state |
| Memory Manager | `register_templates`, `cleanup_patterns`, `cache_system_state` | Memory lifecycle |

### External Integration

| Subsystem | Contract | Pattern |
|-----------|----------|---------|
| Tamiyo | SystemStatePacket, AdaptationCommand | Async field reports |
| Oona | EventEnvelope | Async event publishing |
| Nissa | TelemetryPacket | Async telemetry |
| Urza | BlueprintQuery, BlueprintIR | Async storage |
| Urabrask | ValidationRequest, ValidationResult | Async validation |

### Leyline Contracts Used

This component uses the following shared contracts:
- `leyline.SystemStatePacket` - Process field reports for reward computation
- `leyline.AdaptationCommand` - Strategic generation requests from Tamiyo
- `leyline.EventEnvelope` - Publish blueprint generation events
- `leyline.HardwareContext` - Hardware-aware generation decisions
- `leyline.MessagePriority` - Risk-based message prioritization
- `leyline.SeedLifecycleStage` - Seed operation coordination

## Urza Library Integration

### Centralized Access Control

```python
def get_mutation_templates(self) -> List[Dict[str, Any]]:
    """Get beneficial templates from Urza with Leyline contracts"""
    start_time = perf_counter()

    try:
        # Circuit breaker check
        if not self.circuit_breaker.is_closed():
            return self.conservative_mode.get_cached_templates()

        if not self.urza_library:
            # Circuit breaker instead of RuntimeError crash
            self.circuit_breaker.record_failure()
            return self.conservative_mode.get_cached_templates()

        # Query with access control using Leyline contracts
        query = BlueprintQuery(
            risk_categories=[RiskCategory.BENEFICIAL],
            karn_mutation_allowed=True,  # Only templates Karn can mutate
            production_ready_only=False,  # Include experimental
            requesting_component="karn",
            limit=20,
            schema_version=SchemaVersion.get_version()  # Leyline version
        )

        result = self.urza_library.query_blueprints(query)

        if not result.results:
            # Circuit breaker instead of RuntimeError crash
            self.circuit_breaker.record_failure()
            return self.conservative_mode.get_cached_templates()

        # Convert to templates with Leyline validation
        templates = []
        for blueprint in result.results:
            # Enhanced validation for each template
            if self._validate_template_leyline(blueprint):
                templates.append({
                    "blueprint_id": blueprint.blueprint_id,
                    "name": blueprint.name,
                    "risk_score": blueprint.risk_score,
                    "architecture_spec": blueprint.blueprint_ir,
                    "estimated_speedup": blueprint.estimated_speedup,
                    "tags": blueprint.tags,
                    "leyline_compliant": True,  # Leyline compliance flag
                    "schema_version": SchemaVersion.get_version(),
                    "validation_timestamp_ns": int(time.time() * 1_000_000_000)  # Nanoseconds
                })

        # Memory management - store with TTL
        self._beneficial_templates = templates
        self._last_template_refresh = datetime.now(UTC)
        self.memory_manager.register_templates(templates, ttl_hours=1)

        return templates

    except Exception as e:
        # Circuit breaker failure handling
        self.circuit_breaker.record_failure()
        return self.conservative_mode.get_cached_templates()

    finally:
        # Timing budget monitoring
        duration_ms = (perf_counter() - start_time) * 1000
        if duration_ms > 80:  # 80ms template fetch budget (improved with Leyline)
            self._trigger_conservative_mode("template_fetch_timeout", duration_ms)
```

### Blueprint Storage

```python
async def store_blueprint_in_urza(self, blueprint: BlueprintIR) -> str:
    """Store generated blueprint in Urza library with Leyline EventEnvelope"""
    start_time = perf_counter()

    try:
        # Circuit breaker check
        if not self.circuit_breaker.is_closed():
            # In degraded mode, cache locally and retry later
            await self._cache_blueprint_for_retry(blueprint)
            raise CircuitBreakerOpenError("Urza storage unavailable")

        # Mandatory Urabrask validation before storage
        if not await self.validation_pipeline.validate_with_urabrask_async(blueprint):
            # Failed validation - quarantine instead of storing
            await self._quarantine_blueprint(blueprint, "validation_failed")
            raise ValidationError("Blueprint failed Urabrask validation")

        # Add generation metadata with Leyline compliance
        blueprint.generation_context.update({
            "generator": "karn",
            "generation_time": datetime.now(UTC).isoformat(),
            "generator_version": "3.1",
            "reward_model_version": self.reward_model.version,
            "leyline_compliant": True,  # Leyline compliance flag
            "schema_version": SchemaVersion.get_version(),
            "validation_pipeline_version": self.validation_pipeline.version,
            "circuit_breaker_state": self.circuit_breaker.get_state()
        })

        # Store in Urza with Leyline contracts
        blueprint_message = self._to_leyline_format(blueprint)
        blueprint_id = await self.urza_library.store_blueprint_async(blueprint_message)

        # Publish event using Leyline EventEnvelope
        event_payload = BlueprintGeneratedEvent(
            blueprint_id=blueprint_id,
            operation_type=blueprint.operation_type,
            risk_assessment=blueprint.risk_assessment,
            generator="karn",
            timestamp_ns=int(time.time() * 1_000_000_000),  # Nanoseconds per Leyline
            validation_status="passed",
            schema_version=SchemaVersion.get_version()
        ).SerializeToString()

        event_envelope = EventEnvelope(
            event_id=self._generate_event_id(),
            event_type="blueprint.generated",
            source_subsystem="karn",
            created_at=google.protobuf.Timestamp(seconds=int(time.time())),
            payload=event_payload,
            payload_type="BlueprintGeneratedEvent",
            content_encoding="protobuf",
            priority=MessagePriority.PRIORITY_NORMAL,
            routing_keys=["blueprints", "generation"],
            delivery_guarantee=DeliveryGuarantee.DELIVERY_AT_LEAST_ONCE
        )

        await self.message_bus.publish_event_async(event_envelope)

        # Memory management - track stored blueprints
        self.memory_manager.register_stored_blueprint(blueprint_id, blueprint)

        return blueprint_id

    except Exception as e:
        # Circuit breaker failure handling
        self.circuit_breaker.record_failure()
        await self._handle_storage_failure(blueprint, str(e))
        raise

    finally:
        # Timing budget monitoring
        duration_ms = (perf_counter() - start_time) * 1000
        if duration_ms > 800:  # 800ms storage budget (improved with Leyline)
            self._trigger_conservative_mode("storage_timeout", duration_ms)
```

## Learning from Field Reports

### Reward Model Updates

```python
class RewardModel:
    """Learn from field deployment results with Leyline SystemStatePacket"""

    def __init__(self):
        self.memory_manager = MemoryManager()
        self.circuit_breaker = CircuitBreaker(failure_threshold=3)

        # Bounded data structures with TTL
        self.blueprint_rewards = BoundedDict(max_size=10000, ttl_hours=24)
        self.successful_patterns = BoundedList(max_size=1000, ttl_hours=168)  # 1 week

    def update_from_system_state(self, system_state: SystemStatePacket):
        """Update model based on Leyline SystemStatePacket"""
        start_time = perf_counter()

        try:
            # Circuit breaker check
            if not self.circuit_breaker.is_closed():
                # Cache state for later processing in degraded mode
                self.memory_manager.cache_system_state(system_state)
                return

            # Extract metrics from SystemStatePacket (native map<> support)
            training_metrics = dict(system_state.training_metrics)
            hardware_context = system_state.hardware_context

            # Compute multi-objective reward
            reward = self._compute_reward_from_system_state(system_state, training_metrics)

            # Memory-safe blueprint performance tracking
            blueprint_type = system_state.source_subsystem
            if blueprint_type not in self.blueprint_rewards:
                self.blueprint_rewards[blueprint_type] = BoundedList(max_size=1000)

            self.blueprint_rewards[blueprint_type].append(reward)

            # Track successful patterns with memory bounds
            if reward > 0.7:  # High performance
                pattern_entry = {
                    "experiment_name": system_state.experiment_name,
                    "training_run_id": system_state.training_run_id,
                    "performance": reward,
                    "timestamp_ns": system_state.timestamp_ns,  # Leyline timestamp format
                    "hardware_context": {
                        "device_type": hardware_context.device_type,
                        "memory_gb": hardware_context.available_memory_gb,
                        "utilization": hardware_context.utilization_percent
                    }
                }

                # Memory-bounded successful patterns
                if len(self.successful_patterns) >= self.successful_patterns.max_size:
                    self.successful_patterns.pop(0)  # Remove oldest

                self.successful_patterns.append(pattern_entry)

            # Update generation strategy
            self._update_generation_weights(blueprint_type, reward)

        except Exception as e:
            # Circuit breaker failure handling
            self.circuit_breaker.record_failure()
            self.memory_manager.cache_system_state(system_state)

        finally:
            # Timing budget monitoring
            duration_ms = (perf_counter() - start_time) * 1000
            if duration_ms > 40:  # 40ms system state processing budget (improved)
                self._trigger_conservative_mode("system_state_timeout", duration_ms)

    def _compute_reward_from_system_state(
        self,
        system_state: SystemStatePacket,
        training_metrics: Dict[str, float]
    ) -> float:
        """Multi-objective reward computation using Leyline SystemStatePacket"""
        try:
            # Safe float operations with bounds checking
            performance_score = max(0.0, min(1.0,
                system_state.validation_accuracy))

            stability_score = max(0.0, min(1.0,
                1.0 - system_state.validation_loss))

            # Use training_metrics native map<> for additional signals
            efficiency_bonus = 0.0
            if "gpu_utilization" in training_metrics:
                gpu_util = training_metrics["gpu_utilization"]
                efficiency_bonus = 0.1 if 0.7 <= gpu_util <= 0.9 else -0.05

            # Weighted combination with overflow protection
            reward = (0.5 * performance_score +
                     0.3 * stability_score +
                     0.2 * efficiency_bonus)

            return max(0.0, min(1.0, reward))  # Bounds checking

        except Exception as e:
            # Safe fallback on computation error
            self.circuit_breaker.record_failure()
            return 0.0  # Conservative reward on error
```

### Pattern Recognition

```python
class PatternLibrary:
    """Track successful architectural patterns with Leyline integration"""

    def __init__(self):
        self.memory_manager = MemoryManager()

        # Bounded data structures with TTL cleanup
        self.patterns = BoundedList(max_size=5000, ttl_hours=168)  # 1 week
        self.pattern_performance = BoundedDict(max_size=1000, ttl_hours=168)

    def add_successful_pattern(
        self,
        blueprint: BlueprintIR,
        performance: float,
        system_state: SystemStatePacket = None
    ):
        """Record successful pattern with Leyline context"""
        start_time = perf_counter()

        try:
            pattern = self._extract_pattern(blueprint)

            # Add Leyline context if available
            if system_state:
                pattern.leyline_context = {
                    "current_epoch": system_state.current_epoch,
                    "global_step": system_state.global_step,
                    "hardware_context": {
                        "device_type": system_state.hardware_context.device_type,
                        "memory_gb": system_state.hardware_context.available_memory_gb,
                        "temperature": system_state.hardware_context.temperature_celsius
                    },
                    "training_metrics": dict(system_state.training_metrics),
                    "schema_version": system_state.version
                }

            # Memory-bounded pattern storage
            if len(self.patterns) >= self.patterns.max_size:
                # Remove oldest patterns to prevent memory growth
                oldest_pattern = self.patterns.pop(0)
                # Clean up associated performance data
                if oldest_pattern.signature in self.pattern_performance:
                    del self.pattern_performance[oldest_pattern.signature]

            self.patterns.append(pattern)

            # Memory-bounded performance tracking
            if pattern.signature not in self.pattern_performance:
                self.pattern_performance[pattern.signature] = BoundedList(max_size=100)

            performance_list = self.pattern_performance[pattern.signature]
            if len(performance_list) >= performance_list.max_size:
                performance_list.pop(0)  # Remove oldest performance record

            performance_list.append(performance)

            # Identify reusable components
            if performance > 0.8:
                self._mark_for_template_generation(pattern)

        except Exception as e:
            # Circuit breaker failure handling
            self.memory_manager.handle_pattern_error(blueprint, str(e))

        finally:
            # Memory cleanup every 100 operations
            self.memory_manager.maybe_cleanup_patterns()

            # Timing budget monitoring
            duration_ms = (perf_counter() - start_time) * 1000
            if duration_ms > 8:  # 8ms pattern processing budget (improved with Leyline)
                self._trigger_conservative_mode("pattern_timeout", duration_ms)
```

## Safety & Risk Management

### Risk-Aware Generation

```python
class RiskAwareGenerator:
    """Manage risk in blueprint generation with Leyline integration"""

    def __init__(self):
        self.risk_budget = RiskBudget(
            max_experimental_ratio=0.3,
            max_adversarial_ratio=0.05
        )
        self.risk_assessor = RiskAssessor()

        # Circuit breaker for risk assessment
        self.circuit_breaker = CircuitBreaker(failure_threshold=5)
        self.conservative_mode = ConservativeMode()

    def generate_with_risk_control(
        self,
        context: Dict[str, Any],
        system_state: SystemStatePacket = None,
        risk_tolerance: float = 0.3
    ) -> BlueprintIR:
        """Generate blueprint within risk tolerance using Leyline integration"""
        start_time = perf_counter()

        try:
            # Circuit breaker check
            if not self.circuit_breaker.is_closed():
                return self.conservative_mode.get_minimal_risk_blueprint(context)

            # Use SystemStatePacket for enhanced context
            if system_state:
                # Extract hardware constraints
                hardware_context = system_state.hardware_context
                memory_constraint = hardware_context.available_memory_gb < 8.0
                thermal_constraint = hardware_context.temperature_celsius > 75.0

                # Adjust risk tolerance based on hardware state
                if memory_constraint or thermal_constraint:
                    risk_tolerance *= 0.7  # More conservative under constraint

            # Check current risk exposure
            current_risk = self.risk_budget.get_current_exposure()

            if current_risk > risk_tolerance:
                # Generate conservative blueprint
                return self._generate_conservative_blueprint(context)

            # Normal generation with risk assessment
            blueprint = self.generator.generate_blueprint(context)

            # Assess risk with safety bounds
            try:
                risk_score = self.risk_assessor.assess(blueprint)
                blueprint.risk_assessment = max(0.0, min(1.0, risk_score))  # Bounds check
            except Exception as e:
                # Safe fallback on risk assessment failure
                blueprint.risk_assessment = 1.0  # Conservative max risk
                self.circuit_breaker.record_failure()

            # Update risk budget
            self.risk_budget.add_blueprint(blueprint)

            # Publish risk event using Leyline EventEnvelope
            if blueprint.risk_assessment > 0.7:
                await self._publish_high_risk_event(blueprint, system_state)

            return blueprint

        except Exception as e:
            # Circuit breaker failure handling
            self.circuit_breaker.record_failure()
            return self.conservative_mode.get_minimal_risk_blueprint(context)

        finally:
            # Timing budget monitoring
            duration_ms = (perf_counter() - start_time) * 1000
            if duration_ms > 160:  # 160ms risk assessment budget (improved with Leyline)
                self._trigger_conservative_mode("risk_assessment_timeout", duration_ms)
```

## Configuration

```yaml
karn_template_system:
  # Core settings
  blueprint_library_size: 50
  enable_circuit_breaker: true
  enable_conservative_mode: true

  # Safety configuration
  production_tier:
    blueprints: "BP001-BP035"
    count: 35
    risk_range: [0.0, 0.5]
    validation: "standard"

  experimental_tier:
    blueprints: "BP036-BP042"
    count: 7
    risk_range: [0.5, 0.8]
    validation: "enhanced"

  adversarial_tier:
    blueprints: "BP043-BP050"
    count: 8
    risk_range: [0.8, 1.0]
    validation: "isolated"
    quarantine: true

  # Performance tuning
  generation_budget_ms: 400
  template_fetch_budget_ms: 80
  decision_budget_ms: 150
  storage_budget_ms: 800

  # Memory management
  memory_cleanup_interval: 300  # 5 minutes
  pattern_ttl_hours: 168  # 1 week
  reward_ttl_hours: 24
  max_pattern_count: 5000
  max_reward_entries: 10000
```

### Configuration Validation

- **blueprint_library_size**: Must equal sum of tier counts (35+7+8=50)
- **risk_range**: Must be contiguous across tiers with no gaps
- **generation_budget_ms**: Must be less than Tolaria timeout (5s)
- **memory limits**: Total usage must not exceed 7GB

## Performance Characteristics

### Benchmarks

| Operation | Target | Measured | Conditions |
|-----------|--------|----------|------------|
| Template Selection | 50-100ms | 62ms P50 | 20 templates |
| Mutation Application | 20-50ms | 31ms P50 | Standard mutations |
| Urabrask Validation | 50-120ms | 85ms P50 | Production tier |
| Blueprint Storage | 200-800ms | 420ms P50 | Including validation |
| Field Report Processing | 20-40ms | 28ms P50 | SystemStatePacket |

### Resource Usage

- **Memory**: 5-7GB typical, 10GB peak with full pattern library
- **CPU**: 2-4 cores during generation, 1 core idle
- **I/O**: Burst writes during storage (100KB/blueprint)
- **Network**: 50KB/s average for Leyline messaging

### Optimization Strategies

1. **Template Caching**: Cache frequently used templates for 1 hour
2. **Batch Validation**: Validate multiple blueprints in single Urabrask call
3. **Lazy Pattern Extraction**: Only extract patterns from successful blueprints
4. **Memory Pooling**: Reuse blueprint objects to reduce allocation overhead

## Error Handling

### Failure Modes

| Error Type | Detection | Recovery |
|------------|-----------|----------|
| Generation Timeout | >400ms duration | Conservative mode activation |
| Validation Failure | Urabrask rejection | Blueprint quarantine |
| Memory Exhaustion | >10GB usage | TTL cleanup trigger |
| Circuit Breaker Open | 3+ consecutive failures | Fallback templates only |
| Urza Unavailable | Connection timeout | Local cache + retry queue |

### Circuit Breakers

```python
# Circuit breaker configuration
circuit_breaker = CircuitBreaker(
    failure_threshold=3,        # Open after 3 failures
    recovery_timeout_ms=30000,  # Try recovery after 30s
    half_open_requests=1        # Single test request in half-open
)
```

### Fallback Behavior

When this component fails:
1. Activate conservative mode with minimal-risk templates
2. Use cached templates if Urza unavailable
3. Queue blueprints for later storage if network issues
4. Log all failures with full context for debugging

## Testing Strategy

### Integration Tests

```python
class KarnLeylineIntegrationTests:
    """Test Karn integration with Leyline contracts"""

    async def test_system_state_processing(self):
        """Test processing Leyline SystemStatePacket"""

        # Create Leyline SystemStatePacket
        hardware_context = HardwareContext(
            device_type="cuda",
            device_id="0",
            total_memory_gb=24.0,
            available_memory_gb=16.0,
            temperature_celsius=65.0,
            utilization_percent=85.0,
            compute_capability=86  # RTX 4090
        )

        system_state = SystemStatePacket(
            version=SchemaVersion.get_version(),
            current_epoch=42,
            validation_accuracy=0.87,
            validation_loss=0.15,
            timestamp_ns=int(time.time() * 1_000_000_000),
            hardware_context=hardware_context,
            training_metrics={
                "learning_rate": 0.001,
                "batch_size": 32.0,
                "gpu_utilization": 0.85
            },
            source_subsystem="tamiyo",
            training_run_id="run_001",
            experiment_name="classification_experiment"
        )

        # Process with Karn reward model
        reward_model = RewardModel()
        reward_model.update_from_system_state(system_state)

        # Verify processing
        assert len(reward_model.blueprint_rewards) > 0
        assert reward_model.circuit_breaker.is_closed()
```

Coverage targets:
- Line coverage: >95%
- Branch coverage: >90%
- Critical paths: 100%

## Monitoring & Observability

### Metrics

| Metric | Type | Purpose |
|--------|------|---------|
| `karn_template_generation_duration_ms` | Histogram | Generation performance |
| `karn_blueprint_risk_score` | Histogram | Risk distribution |
| `karn_circuit_breaker_state` | Gauge | System health |
| `karn_memory_usage_bytes` | Gauge | Memory monitoring |
| `karn_urabrask_validation_failures` | Counter | Safety violations |

### Logging

```python
# Logging levels and patterns
logger.debug(f"Karn: Selected template {template_id} for {context}")
logger.info(f"Karn: Generated blueprint {blueprint_id} risk={risk_score}")
logger.warning(f"Karn: Circuit breaker open, using conservative mode")
logger.error(f"Karn: Validation failed for {blueprint_id}", exc_info=True)
```

## References

### Internal References
- Parent: [05-karn-unified-design.md](05-karn-unified-design.md)
- Related: [05.2-karn-generative-ai.md](05.2-karn-generative-ai.md)
- Tests: `tests/karn/template_system/`

### External References
- [Leyline Shared Contracts](00-leyline-shared-contracts.md)
- [C-014 Conclave Decision](docs/ai/conclaves/C-014)
- [Urabrask Validation Engine](07-urabrask-unified-design.md)

---

*Component Owner: System Architecture Team | Last Updated: 2025-01-14*