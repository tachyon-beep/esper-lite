# Leyline - Enums and Constants

## Document Metadata

| Field | Value |
|-------|-------|
| **Parent Document** | [[00-leyline-shared-contracts.md]] |
| **Component Type** | Virtual/Contract Library |
| **Version** | 1.0 |
| **Status** | PRODUCTION |
| **Implementation** | Complete |

## Overview

This component defines all shared enumerations and system constants used across the Esper morphogenetic neural network training platform. These definitions ensure consistent state representation, priority handling, and resource allocation across all subsystems. All constants are optimized for the performance targets established by the greenfield design.

Key characteristics:
- **Standardized States**: Consistent lifecycle and health representations
- **Performance Budgets**: Strict timing and memory constraints
- **System Limits**: Clear boundaries for resource usage

## Technical Design

### Architecture

```
Leyline Enums & Constants
├── Lifecycle Enums
│   ├── SeedLifecycleStage
│   ├── HealthStatus
│   └── CircuitBreakerState
├── Command & Operation Enums
│   ├── CommandType
│   ├── Operation Types (Seed, Optimizer, etc.)
│   └── Pruning Operations (C-020)
├── Priority & Delivery Enums
│   ├── MessagePriority
│   ├── TelemetryLevel
│   └── DeliveryGuarantee
└── System Constants
    ├── PerformanceBudgets
    ├── MemoryBudgets
    └── SystemLimits
```

### Core Abstractions

**Lifecycle Management Enums**
```protobuf
// Seed lifecycle stages - defines morphogenetic evolution states
enum SeedLifecycleStage {
  SEED_STAGE_UNKNOWN = 0;
  SEED_STAGE_DORMANT = 1;        // Quiescent slot ready for germination
  SEED_STAGE_GERMINATED = 2;     // Sanity checks and registration
  SEED_STAGE_TRAINING = 3;       // Isolated training path
  SEED_STAGE_BLENDING = 4;       // Alpha-managed grafting
  SEED_STAGE_SHADOWING = 5;      // Stabilisation probe
  SEED_STAGE_PROBATIONARY = 6;   // System impact observation
  SEED_STAGE_FOSSILIZED = 7;     // Permanent preservation
  SEED_STAGE_CULLED = 8;         // Failure path activated
  SEED_STAGE_EMBARGOED = 9;      // Cooldown to prevent thrash
  SEED_STAGE_RESETTING = 10;     // Slot cleanup prior to reuse
  SEED_STAGE_TERMINATED = 11;    // Administrative teardown
}
```

**Health Status Hierarchy**
- Purpose: Standardize subsystem health reporting
- Key States: HEALTHY, DEGRADED, UNHEALTHY, CRITICAL
- State Management: Progressive degradation model

### Algorithms

#### Enum Value Assignment Strategy

**Purpose**: Prevent value collisions and enable safe evolution

**Approach**:
1. Reserve value 0 for UNKNOWN/UNSPECIFIED states
2. Assign sequential values within logical groups
3. Never reuse enum values (even after deprecation)
4. Reserve ranges for future expansion

**Complexity**:
- Time: O(1) for enum lookup
- Space: O(1) per enum value

### Data Structures

#### PerformanceBudgets

```protobuf
message PerformanceBudgets {
  // Epoch boundary operations (milliseconds)
  uint32 EPOCH_BOUNDARY_MS = 18;
  uint32 TAMIYO_INFERENCE_MS = 12;
  uint32 SYSTEMSTATE_ASSEMBLY_MS = 3;
  uint32 ADAPTATION_PROCESSING_MS = 2;

  // Rollback timing
  uint32 FAST_ROLLBACK_MS = 500;
  uint32 FULL_ROLLBACK_SECONDS = 12;

  // Serialization (microseconds)
  uint32 PROTOBUF_SERIALIZATION_US = 80;
  uint32 MESSAGE_VALIDATION_US = 20;

  // Circuit breaker
  uint32 BREAKER_TIMEOUT_MS = 1000;
  uint32 BREAKER_RESET_SECONDS = 30;

  // C-020 Structured pruning budgets
  uint32 IMPORTANCE_TRACKING_OVERHEAD_PERCENT = 1;  // <0.1% training overhead
  uint32 CHECKPOINT_ANALYSIS_MINUTES_MIN = 2;       // 2-5 minute analysis window
  uint32 CHECKPOINT_ANALYSIS_MINUTES_MAX = 5;
  uint32 STRUCTURED_VALIDATION_SECONDS = 60;        // Urabrask validation timeout
  uint32 ROLLBACK_COORDINATION_SECONDS = 30;        // Emergency rollback time
}
```

**Usage**: Enforced by all subsystems for performance compliance

**Constraints**: All timings are hard limits, not targets

#### MemoryBudgets

```protobuf
message MemoryBudgets {
  float MODEL_PERCENT = 0.40;              // 40% for model weights
  float OPTIMIZER_PERCENT = 0.25;          // 25% for optimizer state
  float GRADIENTS_PERCENT = 0.15;          // 15% for gradient buffers
  float CHECKPOINTS_PERCENT = 0.08;        // 8% for checkpointing
  float TELEMETRY_PERCENT = 0.05;          // 5% for observability
  float MORPHOGENETIC_PERCENT = 0.05;      // 5% for evolution
  float EMERGENCY_PERCENT = 0.02;          // 2% emergency reserve

  // C-020 Additional memory budgets
  float IMPORTANCE_STATISTICS_PERCENT = 0.03;  // Importance tracking data
  float PRUNING_METADATA_PERCENT = 0.02;       // Pruning masks and metadata
}
```

#### SystemLimits

```protobuf
message SystemLimits {
  uint32 MAX_SEEDS_PER_EPOCH = 100;
  uint32 MAX_MESSAGE_SIZE_BYTES = 280;      // Optimized message size
  uint32 MAX_QUEUE_DEPTH = 10000;
  uint32 MAX_RETRY_ATTEMPTS = 3;
  uint32 MAX_PAUSE_QUOTA = 10000;
  uint32 MAX_GC_ALLOCATIONS_PER_MSG = 4;    // GC allocation limit

  // C-020 Structured pruning limits
  uint32 MAX_PRUNING_RATIO_PERCENT = 50;        // Maximum 50% parameter removal
  uint32 MAX_CONSECUTIVE_PRUNING_FAILURES = 3;  // Circuit breaker threshold
  uint32 MAX_CHECKPOINT_STORAGE_GB = 100;       // Storage quota for rollback
  uint32 MAX_IMPORTANCE_HISTORY_DAYS = 30;      // Importance statistics retention
}
```

#### Command Type Enumerations

```protobuf
// Top-level command categorization
enum CommandType {
  COMMAND_UNKNOWN = 0;
  COMMAND_SEED = 1;
  COMMAND_ROLLBACK = 2;
  COMMAND_OPTIMIZER = 3;
  COMMAND_CIRCUIT_BREAKER = 4;
  COMMAND_PAUSE = 5;
  COMMAND_EMERGENCY = 6;
  COMMAND_STRUCTURAL_PRUNING = 7;  // C-020 Addition
}

// Seed-specific operations
enum SeedOperation {
  SEED_OP_UNKNOWN = 0;
  SEED_OP_GERMINATE = 1;
  SEED_OP_START_TRAINING = 2;
  SEED_OP_START_GRAFTING = 3;
  SEED_OP_STABILIZE = 4;
  SEED_OP_EVALUATE = 5;
  SEED_OP_FINE_TUNE = 6;
  SEED_OP_FOSSILIZE = 7;
  SEED_OP_CULL = 8;
  SEED_OP_CANCEL = 9;
}
```

#### Structured Pruning Enums (C-020)

```protobuf
// Pruning phase progression
enum PruningPhase {
  PRUNING_PHASE_UNKNOWN = 0;
  PRUNING_PHASE_VALIDATION_ONLY = 1;    // Phase 1: Telemetry only (Epochs 1-30)
  PRUNING_PHASE_ACTIVE_PRUNING = 2;     // Phase 2: Active pruning (Epochs 31+)
  PRUNING_PHASE_DISABLED = 3;           // Pruning completely disabled
}

// Pruning decision outcomes
enum PruningDecision {
  PRUNING_DECISION_UNKNOWN = 0;
  PRUNING_DECISION_GO = 1;              // Approved for deployment
  PRUNING_DECISION_NO_GO = 2;           // Rejected, rollback required
  PRUNING_DECISION_CONDITIONAL_GO = 3;  // Approved with monitoring
}

// Pruning mask types
enum PruningMaskType {
  PRUNING_MASK_UNKNOWN = 0;
  PRUNING_MASK_CHANNEL = 1;             // Channel-wise pruning
  PRUNING_MASK_ATTENTION_HEAD = 2;      // Attention head pruning
  PRUNING_MASK_LAYER = 3;               // Layer-wise pruning
  PRUNING_MASK_UNSTRUCTURED = 4;        // Unstructured parameter pruning
}

// Pruning operations
enum PruningOperation {
  PRUNING_OP_UNKNOWN = 0;
  PRUNING_OP_ANALYZE = 1;               // Perform importance analysis
  PRUNING_OP_VALIDATE = 2;              // Validate pruning decisions
  PRUNING_OP_APPLY = 3;                 // Apply pruning masks
  PRUNING_OP_ROLLBACK = 4;              // Rollback pruning changes
  PRUNING_OP_PHASE_TRANSITION = 5;      // Transition between phases
}
```

## Integration Points

### Internal Integration

| Component | Interface | Data Flow |
|-----------|-----------|-----------|
| Message Contracts | Import enums | Enum values in messages |
| Subsystem Code | Import constants | Performance budgets |
| Validation Logic | Check limits | System constraint enforcement |

### External Integration

| Subsystem | Contract | Pattern |
|-----------|----------|---------|
| All Subsystems | All enums and constants | Direct import |
| Tolaria (01) | SeedLifecycleStage, PerformanceBudgets | State management |
| Kasmina (02) | MemoryBudgets, SystemLimits | Resource allocation |
| Tamiyo (03) | CommandType, all operations | Command dispatch |
| Elesh (13) | PruningPhase, PruningDecision | C-020 pruning control |

### Leyline Contracts Used

This component defines Leyline enums and constants - it doesn't use them, it provides them.

## Configuration

```yaml
enums_constants:
  # Enum management
  strict_ordering: true      # Enforce sequential enum values
  reserve_unknown: true      # Always reserve 0 for UNKNOWN

  # Constant validation
  validate_budgets: true     # Check budget allocations sum to 100%
  enforce_limits: true       # Hard enforce system limits
```

### Configuration Validation

- **Performance budgets**: Must not exceed hardware capabilities
- **Memory budgets**: Must sum to ≤100%
- **System limits**: Must be achievable on target hardware

## Performance Characteristics

### Benchmarks

| Operation | Target | Measured | Conditions |
|-----------|--------|----------|------------|
| Enum lookup | <1ns | TBD | Direct integer comparison |
| Constant access | <1ns | TBD | Compile-time resolution |
| Budget validation | <1μs | TBD | Runtime check |

### Resource Usage

- **Memory**: Zero runtime overhead (compile-time constants)
- **CPU**: Negligible - integer comparisons
- **I/O**: N/A
- **GPU**: N/A

### Optimization Strategies

1. **Compile-Time Resolution**: Constants resolved at compilation
2. **Integer Enums**: Use integers for maximum performance
3. **Packed Values**: Group related constants for cache locality

## Error Handling

### Failure Modes

| Error Type | Detection | Recovery |
|------------|-----------|----------|
| Invalid Enum Value | Runtime check | Use UNKNOWN fallback |
| Budget Violation | Startup validation | Refuse to start |
| Limit Exceeded | Runtime check | Circuit breaker activation |

### Circuit Breakers

```python
# Using circuit breaker constants
if consecutive_failures > SystemLimits.MAX_CONSECUTIVE_PRUNING_FAILURES:
    activate_circuit_breaker()
```

### Fallback Behavior

When encountering invalid enum values:
1. Log warning with invalid value
2. Default to UNKNOWN state
3. Continue operation in safe mode

## Testing Strategy

### Unit Tests

```python
def test_memory_budget_totals():
    """Test memory budgets sum to ≤100%"""
    total = (MemoryBudgets.MODEL_PERCENT +
             MemoryBudgets.OPTIMIZER_PERCENT +
             MemoryBudgets.GRADIENTS_PERCENT +
             MemoryBudgets.CHECKPOINTS_PERCENT +
             MemoryBudgets.TELEMETRY_PERCENT +
             MemoryBudgets.MORPHOGENETIC_PERCENT +
             MemoryBudgets.EMERGENCY_PERCENT)
    assert total <= 1.0
```

Coverage targets:
- All enum values tested
- All constants validated
- Edge cases covered

### Integration Tests

- **Test**: Enum consistency across subsystems
  - **Setup**: Import in all subsystems
  - **Validation**: Identical values everywhere

### Property-Based Tests

```python
@hypothesis.given(
    stage=strategies.sampled_from(SeedLifecycleStage)
)
def test_lifecycle_transitions(stage):
    """Property: All lifecycle stages have valid transitions"""
    assert stage >= 0
    assert stage <= SeedLifecycleStage.SEED_STAGE_TERMINATED
```

## Monitoring & Observability

### Metrics

| Metric | Type | Purpose |
|--------|------|---------|
| `leyline.budget.violations` | Counter | Budget constraint violations |
| `leyline.limit.exceeded` | Counter | System limit violations |
| `leyline.enum.invalid` | Counter | Invalid enum value encounters |

### Logging

```python
# Logging patterns for constraint violations
logger.warning(f"Memory budget exceeded: {usage:.1%} > {budget:.1%}")
logger.error(f"System limit violated: {value} > {limit}")
logger.debug(f"Enum transition: {old_state} → {new_state}")
```

### Tracing

- **Span**: `leyline.validate_constraints`
  - **Attributes**: constraint_type, value, limit
  - **Events**: validation_passed, validation_failed

## Security Considerations

- **Input Validation**: All enum values validated before use
- **Access Control**: N/A (compile-time constants)
- **Data Handling**: No sensitive data in enums/constants
- **Audit Trail**: Constraint violations logged for analysis

## Migration Notes

> **From Version 0.x**: Not applicable - greenfield design

> **To Leyline**: Import from `esper.leyline.enums` and `esper.leyline.constants`

## Implementation Checklist

- [x] Core algorithm implementation
- [x] Data structure definitions
- [x] Integration interfaces
- [x] Error handling and circuit breakers
- [ ] Unit test coverage >90%
- [ ] Integration tests complete
- [ ] Performance benchmarks met
- [ ] Documentation updated
- [ ] Security review passed
- [ ] Production monitoring ready

## References

### Internal References
- Parent: [[00-leyline-shared-contracts.md]]
- Related: [[00.1-leyline-message-contracts.md]]
- Tests: `tests/leyline/enums/`

### External References
- Protocol Buffers Enum Best Practices
- System Resource Management Guide
- Performance Budget Allocation Patterns

## History & Context

### Implementation Notes
- **2025-01-15**: Migrated from migration/ with template structure
- **2025-01-14**: C-020 pruning enums and constants added
- **2025-01-14**: Greenfield optimization - removed compatibility enums

### Known Issues
- **VALID-001**: Budget validation logic pending implementation
- **TEST-001**: Property-based tests need expansion

---

*Component Owner: Data Architect | Last Updated: 2025-01-15*
