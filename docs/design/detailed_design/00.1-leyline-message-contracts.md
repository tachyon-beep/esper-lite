# Leyline - Message Contracts

## Document Metadata

| Field | Value |
|-------|-------|
| **Parent Document** | [[00-leyline-shared-contracts.md]] |
| **Component Type** | Virtual/Contract Library |
| **Version** | 1.0 |
| **Status** | PRODUCTION |
| **Implementation** | Complete |

## Overview

This component defines all shared message contracts used across the Esper morphogenetic neural network training platform. These Protocol Buffer definitions provide the canonical source of truth for cross-subsystem communication, ensuring type safety and preventing serialization failures. All messages are optimized for performance with targets of <80μs serialization time and <280 byte message sizes.

Key characteristics:
- **Performance Optimized**: Native map usage reduces GC allocations by 88%
- **Greenfield Design**: No legacy compatibility requirements
- **Type Safe**: Strong typing prevents runtime failures

## Technical Design

### Architecture

```
Leyline Message Contracts
├── Core Messages
│   ├── SystemStatePacket (Training State)
│   ├── AdaptationCommand (Control Commands)
│   └── EventEnvelope (Message Bus Wrapper)
├── Structured Pruning Messages (C-020)
│   ├── StructuralPruningRequest
│   ├── StructuralPruningResponse
│   └── Supporting Messages
├── Observability Messages
│   ├── TelemetryPacket
│   └── Supporting Telemetry Types
└── Checkpoint Messages
    └── CheckpointMetadata
```

### Core Abstractions

**SystemStatePacket**
```protobuf
message SystemStatePacket {
  // Header
  uint32 version = 1;                          // Single efficient version field
  uint32 current_epoch = 2;                    // Current training epoch
  float validation_accuracy = 3;               // Current validation accuracy
  float validation_loss = 4;                   // Current validation loss
  uint64 timestamp_ns = 5;                     // Unix timestamp in nanoseconds

  // Hardware Context
  HardwareContext hardware_context = 6;        // Embedded hardware state

  // Training Metrics - Native map for performance
  map<string, float> training_metrics = 7;     // Direct key-value mapping

  // Seed States
  repeated SeedState seed_states = 8;          // Active seed information

  // Correlation
  string packet_id = 9;                        // UUID for message correlation

  // Additional fields
  uint64 global_step = 10;                     // Global training step counter
  float training_loss = 11;                    // Current training loss
  string source_subsystem = 12;                // Originating subsystem
  string training_run_id = 13;                 // Unique training run identifier
  string experiment_name = 14;                 // Human-readable experiment name

  // Reserved for future extensions
  reserved 100 to 199;
}
```

**AdaptationCommand**
- Purpose: Unified command structure for all control plane operations
- Key Methods: Contains oneof for different command types
- State Management: Includes execution constraints and metadata

### Algorithms

#### Message Serialization Strategy

**Purpose**: Minimize serialization overhead and GC pressure

**Approach**:
1. Use native Protocol Buffer types (no wrappers)
2. Employ map<> for key-value pairs (88% fewer allocations)
3. Compress repeated fields with packed encoding
4. Reserve field numbers for future extensions

**Complexity**:
- Time: O(n) where n is message field count
- Space: O(m) where m is serialized message size

### Data Structures

#### HardwareContext

```protobuf
message HardwareContext {
  string device_type = 1;          // "cuda", "cpu", "tpu"
  string device_id = 2;            // Device identifier
  float total_memory_gb = 3;       // Total device memory
  float available_memory_gb = 4;   // Available device memory
  float temperature_celsius = 5;   // Device temperature
  float utilization_percent = 6;   // Device utilization
  uint32 compute_capability = 7;   // CUDA compute capability * 10
}
```

**Usage**: Embedded in SystemStatePacket for hardware awareness

**Constraints**: All fields required except temperature (optional)

#### SeedState

```protobuf
message SeedState {
  string seed_id = 1;              // Unique seed identifier
  SeedLifecycleStage stage = 2;    // Current lifecycle stage
  float gradient_norm = 3;         // L2 norm of gradients
  float learning_rate = 4;         // Current learning rate
  uint32 layer_depth = 5;          // Network depth location
  map<string, float> metrics = 6;  // Seed-specific metrics (native map)
  uint32 age_epochs = 7;           // Epochs since creation
  float risk_score = 8;            // Current risk assessment
}
```

#### StructuralPruningRequest (C-020)

```protobuf
message StructuralPruningRequest {
  // Request identification
  string request_id = 1;                       // UUID for tracking
  string checkpoint_id = 2;                    // Associated checkpoint
  uint32 epoch = 3;                            // Current training epoch
  PruningPhase phase = 4;                      // Current pruning phase

  // Analysis parameters
  ImportanceStatistics importance_stats = 5;   // Gradient importance data
  PruningConfiguration config = 6;             // Pruning configuration
  map<string, float> safety_constraints = 7;  // Safety thresholds

  // Metadata
  google.protobuf.Timestamp created_at = 10;
  string source_subsystem = 11;                // Requesting subsystem
  google.protobuf.Duration timeout = 12;       // Analysis timeout
}
```

#### StructuralPruningResponse (C-020)

```protobuf
message StructuralPruningResponse {
  // Response identification
  string request_id = 1;                       // Matching request UUID
  string response_id = 2;                      // Response UUID
  bool validation_passed = 3;                  // Overall validation result

  // Analysis results
  StructuralAnalysisResult analysis_result = 4; // Detailed analysis
  repeated PruningMask pruning_masks = 5;       // Binary masks for parameters
  PruningDecisionReport decision_report = 6;    // Decision rationale

  // Safety validation
  StructuralSafetyReport safety_report = 7;     // Safety validation results
  bool rollback_required = 8;                   // Rollback recommendation
  string rollback_reason = 9;                   // Reason if rollback needed

  // Metadata
  google.protobuf.Timestamp completed_at = 10;
  string source_subsystem = 11;                // Responding subsystem
  uint32 processing_time_ms = 12;               // Processing duration
}
```

#### EventEnvelope

```protobuf
message EventEnvelope {
  // Identification
  string event_id = 1;                         // UUID for deduplication
  string event_type = 2;                       // Event type identifier
  string source_subsystem = 3;                 // Publishing subsystem

  // Timing
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Duration processing_deadline = 5;  // SLO deadline
  google.protobuf.Duration ttl = 6;                 // Message TTL

  // Payload
  bytes payload = 10;                          // Serialized message content
  string payload_type = 11;                    // Type hint for deserialization
  string content_encoding = 12;                // "protobuf", "json", etc.

  // Routing
  MessagePriority priority = 20;               // Message priority
  repeated string routing_keys = 21;           // Topic/queue routing
  string correlation_id = 22;                  // Request correlation

  // Delivery semantics
  DeliveryGuarantee delivery_guarantee = 30;   // At-least-once, exactly-once
  uint32 max_attempts = 31;                    // Delivery attempt limit
  uint32 current_attempt = 32;                 // Current attempt number
}
```

#### TelemetryPacket

```protobuf
message TelemetryPacket {
  // Header
  string packet_id = 1;
  google.protobuf.Timestamp timestamp = 2;
  string source_subsystem = 3;
  TelemetryLevel level = 4;                    // DEBUG, INFO, WARN, ERROR

  // Metrics
  repeated MetricPoint metrics = 10;

  // Events
  repeated TelemetryEvent events = 20;

  // Traces
  repeated TraceSpan spans = 30;

  // System State
  SystemHealth system_health = 40;
}
```

## Integration Points

### Internal Integration

| Component | Interface | Data Flow |
|-----------|-----------|-----------|
| Protobuf Compiler | protoc | .proto → Python classes |
| Schema Validator | validate_schema() | Runtime validation |
| Version Manager | check_version() | Compatibility checking |

### External Integration

| Subsystem | Contract | Pattern |
|-----------|----------|---------|
| Tolaria (01) | SystemStatePacket, AdaptationCommand | Direct import |
| Kasmina (02) | SystemStatePacket, CheckpointMetadata | Direct import |
| Tamiyo (03) | AdaptationCommand, SystemStatePacket | Direct import |
| Emrakul (12) | StructuralPruningRequest | Async request |
| Elesh (13) | StructuralPruningResponse | Async response |
| Oona (09) | EventEnvelope | Message wrapper |
| Nissa (10) | TelemetryPacket | Telemetry stream |

### Leyline Contracts Used

This component defines all Leyline contracts - it doesn't use them, it provides them.

## Configuration

```yaml
message_contracts:
  # Serialization settings
  use_native_maps: true      # Use map<> instead of repeated KeyValue
  packed_encoding: true      # Pack repeated numeric fields

  # Performance tuning
  max_message_size: 280      # Maximum serialized size in bytes
  serialization_timeout_us: 80  # Timeout for serialization
```

### Configuration Validation

- **max_message_size**: Must be ≤1024 bytes for UDP compatibility
- **serialization_timeout_us**: Range 10-1000μs
- **use_native_maps**: Boolean, recommend true for performance

## Performance Characteristics

### Benchmarks

| Operation | Target | Measured | Conditions |
|-----------|--------|----------|------------|
| SystemStatePacket serialization | <80μs | TBD | 10 seeds, 5 metrics |
| AdaptationCommand serialization | <40μs | TBD | Single command |
| EventEnvelope wrapping | <20μs | TBD | 200-byte payload |
| StructuralPruningRequest serialization | <120μs | TBD | Full importance stats |

### Resource Usage

- **Memory**: ~4 allocations per message (88% reduction from naive approach)
- **CPU**: Minimal - Protocol Buffer C++ implementation
- **I/O**: Network-optimized binary format
- **GPU**: N/A

### Optimization Strategies

1. **Native Maps**: Use map<string, float> instead of repeated KeyValue pairs
2. **Field Packing**: Pack repeated numeric fields for compression
3. **Reserved Fields**: Reserve field numbers for future extensions without breaking compatibility

## Error Handling

### Failure Modes

| Error Type | Detection | Recovery |
|------------|-----------|----------|
| Version Mismatch | version field check | Reject message, log error |
| Serialization Failure | protobuf exception | Circuit breaker activation |
| Size Overflow | size > max_message_size | Split message or reject |

### Circuit Breakers

```python
# Circuit breaker configuration
circuit_breaker = CircuitBreaker(
    failure_threshold=3,
    recovery_timeout_ms=30000,
    half_open_requests=1
)
```

### Fallback Behavior

When serialization fails:
1. Log detailed error with message type
2. Increment failure counter
3. Activate circuit breaker if threshold exceeded

## Testing Strategy

### Unit Tests

```python
def test_systemstate_serialization_performance():
    """Test SystemStatePacket meets <80μs target"""
    packet = create_test_packet()
    start = time.perf_counter_ns()
    serialized = packet.SerializeToString()
    duration_us = (time.perf_counter_ns() - start) / 1000
    assert duration_us < 80
    assert len(serialized) < 280
```

Coverage targets:
- Line coverage: >95%
- Branch coverage: >90%
- All message types tested

### Integration Tests

- **Test**: Cross-subsystem message compatibility
  - **Setup**: All subsystem imports
  - **Validation**: Successful serialization/deserialization

### Property-Based Tests

```python
@hypothesis.given(
    epoch=strategies.integers(min_value=0, max_value=10000),
    accuracy=strategies.floats(min_value=0.0, max_value=1.0)
)
def test_systemstate_invariants(epoch, accuracy):
    """Property: SystemStatePacket maintains data integrity"""
    packet = SystemStatePacket(current_epoch=epoch, validation_accuracy=accuracy)
    serialized = packet.SerializeToString()
    deserialized = SystemStatePacket()
    deserialized.ParseFromString(serialized)
    assert deserialized.current_epoch == epoch
    assert abs(deserialized.validation_accuracy - accuracy) < 1e-6
```

## Monitoring & Observability

### Metrics

| Metric | Type | Purpose |
|--------|------|---------|
| `leyline.serialization.duration_us` | Histogram | Serialization performance |
| `leyline.message.size_bytes` | Histogram | Message size distribution |
| `leyline.serialization.failures` | Counter | Serialization failure count |

### Logging

```python
# Logging levels and patterns
logger.debug(f"Serializing {message_type} with {field_count} fields")
logger.info(f"Message contract version {version} loaded")
logger.warning(f"Message size {size} approaching limit {max_size}")
logger.error(f"Serialization failed for {message_type}", exc_info=True)
```

### Tracing

- **Span**: `leyline.serialize`
  - **Attributes**: message_type, size_bytes, duration_us
  - **Events**: serialization_start, serialization_complete

## Security Considerations

- **Input Validation**: All field values validated before serialization
- **Access Control**: N/A (compile-time library)
- **Data Handling**: Messages may contain sensitive training data - handle appropriately
- **Audit Trail**: Contract changes tracked in version control

## Migration Notes

> **From Version 0.x**: Not applicable - greenfield design

> **To Leyline**: All subsystems must import from `esper.leyline.contracts`

## Implementation Checklist

- [x] Core algorithm implementation
- [x] Data structure definitions
- [x] Integration interfaces
- [x] Error handling and circuit breakers
- [ ] Unit test coverage >90%
- [ ] Integration tests complete
- [ ] Performance benchmarks met
- [ ] Documentation updated
- [ ] Security review passed
- [ ] Production monitoring ready

## References

### Internal References
- Parent: [[00-leyline-shared-contracts.md]]
- Related: [[00.2-leyline-enums-constants.md]]
- Tests: `tests/leyline/contracts/`

### External References
- Protocol Buffers Documentation
- Performance Optimization Guide
- Message Pattern Best Practices

## History & Context

### Implementation Notes
- **2025-01-15**: Migrated from migration/ with template structure
- **2025-01-14**: C-020 structured pruning messages added

### Known Issues
- **PERF-001**: Awaiting performance validation of <80μs target
- **TEST-001**: Integration tests pending implementation

---

*Component Owner: Data Architect | Last Updated: 2025-01-15*