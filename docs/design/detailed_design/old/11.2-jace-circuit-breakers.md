# Jace - Circuit Breaker Architecture

**Parent Document**: [11-jace-unified-design.md](11-jace-unified-design.md)
**Component Type**: Safety Architecture
**Version**: 3.0
**Leyline Integration**: COMPLETE - Integrated with Leyline (shared contracts) per Option B

---

## Overview

This document specifies the comprehensive circuit breaker architecture for Jace curriculum coordination, implementing three-state protection with conservative mode triggers and comprehensive fallback strategies. The circuit breaker system ensures graceful degradation under all failure conditions while maintaining coordination functionality. All safety mechanisms integrate with Leyline (shared contracts) for consistent cross-subsystem communication.

## 1. Circuit Breaker Implementation

### 1.1 Core Circuit Breaker

```python
from typing import Dict, Optional, Callable, Any
from enum import Enum
from dataclasses import dataclass
from time import perf_counter
import logging

# Import from Leyline (shared contracts)
from esper.leyline.contracts import (
    SystemStatePacket,
    AdaptationCommand,
    TelemetryPacket,
    CircuitBreakerState,
    HealthStatus,
    SafetyViolation,
    MessagePriority,
    TelemetryLevel
)
from esper.leyline.version import SchemaVersion

@dataclass
class CircuitBreakerConfig:
    failure_threshold: int = 5
    recovery_timeout_ms: int = 30000  # 30 seconds
    success_threshold: int = 3
    timeout_ms: int = 18  # 18ms for coordination decisions

class CoordinationCircuitBreaker:
    """[C-016] Circuit breaker for coordination decisions with Leyline integration"""

    def __init__(self, config: CircuitBreakerConfig):
        self.config = config
        self.state = CircuitBreakerState.BREAKER_CLOSED  # Use Leyline enum
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time_ms: Optional[float] = None

        # Conservative mode triggers
        self.metrics = MetricsCollector()
        self.conservative_mode_enabled = False

    def call(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function with circuit breaker protection"""

        if self.state == CircuitBreakerState.BREAKER_OPEN:
            if self._should_attempt_reset():
                self.state = CircuitBreakerState.BREAKER_HALF_OPEN
                self.success_count = 0
            else:
                self.metrics.circuit_breaker_rejects.inc()
                return self._get_fallback_result()

        start_time = perf_counter()

        try:
            # Execute with timeout protection
            result = self._execute_with_timeout(func, *args, **kwargs)
            self._record_success()

            # Track timing for SLO monitoring
            duration_ms = (perf_counter() - start_time) * 1000
            self.metrics.coordination_duration_ms.observe(duration_ms)

            if duration_ms > self.config.timeout_ms:
                self._trigger_conservative_mode(f"Coordination took {duration_ms}ms > {self.config.timeout_ms}ms")

            return result

        except Exception as e:
            self._record_failure(str(e))
            self.metrics.coordination_failures.inc()
            return self._get_fallback_result()

    def _execute_with_timeout(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function with timeout protection"""
        # Implementation would use threading.Timer or asyncio.wait_for
        # for actual timeout enforcement
        return func(*args, **kwargs)

    def _record_success(self):
        """Record successful execution"""
        if self.state == CircuitBreakerState.BREAKER_HALF_OPEN:
            self.success_count += 1
            if self.success_count >= self.config.success_threshold:
                self.state = CircuitBreakerState.BREAKER_CLOSED
                self.failure_count = 0
                logging.info("Circuit breaker recovered to CLOSED state")
                self._emit_telemetry_event("circuit_breaker_recovered", TelemetryLevel.TELEMETRY_INFO)
        else:
            self.failure_count = max(0, self.failure_count - 1)

    def _record_failure(self, error: str):
        """Record failed execution"""
        self.failure_count += 1
        self.last_failure_time_ms = perf_counter() * 1000

        if self.failure_count >= self.config.failure_threshold:
            self.state = CircuitBreakerState.BREAKER_OPEN
            self._trigger_conservative_mode(f"Circuit breaker opened due to failures: {error}")
            logging.warning(f"Circuit breaker opened: {error}")
            self._emit_telemetry_event("circuit_breaker_opened", TelemetryLevel.TELEMETRY_WARN, {"error": error})

    def _should_attempt_reset(self) -> bool:
        """Check if circuit breaker should attempt recovery"""
        if self.last_failure_time_ms is None:
            return True

        time_since_failure = (perf_counter() * 1000) - self.last_failure_time_ms
        return time_since_failure >= self.config.recovery_timeout_ms

    def _trigger_conservative_mode(self, reason: str):
        """[C-016] Trigger conservative mode instead of crashing"""
        if not self.conservative_mode_enabled:
            self.conservative_mode_enabled = True
            self.metrics.conservative_mode_triggers.inc()
            logging.warning(f"Entering conservative mode: {reason}")

            # Emit SafetyViolation via Leyline TelemetryPacket
            self._emit_safety_violation(reason)

            # Conservative policies:
            # - Use simpler coordination algorithms
            # - Increase timeout budgets by 50%
            # - Reduce telemetry sampling by 50%
            # - Disable experimental features

    def _emit_safety_violation(self, reason: str):
        """Emit SafetyViolation using Leyline telemetry"""

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_WARN,
            events=[
                TelemetryEvent(
                    event_name="safety_violation",
                    severity=TelemetryLevel.TELEMETRY_WARN,
                    message=f"Circuit breaker safety violation: {reason}",
                    attributes={
                        "violation_type": "circuit_breaker_failure",
                        "subsystem": "jace",
                        "circuit_breaker_state": self.state.name,
                        "failure_count": str(self.failure_count)
                    },
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        # Send via Oona message bus
        self._send_telemetry_packet(telemetry_packet)

    def _emit_telemetry_event(self, event_name: str, level: TelemetryLevel, attributes: Dict[str, str] = None):
        """Emit telemetry event using Leyline TelemetryPacket"""

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=level,
            events=[
                TelemetryEvent(
                    event_name=event_name,
                    severity=level,
                    message=f"Circuit breaker event: {event_name}",
                    attributes=attributes or {},
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        self._send_telemetry_packet(telemetry_packet)

    def _get_fallback_result(self) -> Any:
        """Conservative fallback coordination decision"""
        return FallbackCoordinator().get_safe_decision()

    def get_state_for_telemetry(self) -> CircuitBreakerState:
        """Get current circuit breaker state for telemetry reporting"""
        return self.state
```

### 1.2 Multi-Tier Fallback System

```python
class FallbackCoordinator:
    """[C-016] Conservative fallback coordination with Leyline integration"""

    def get_safe_decision(self) -> 'CoordinationDecision':
        """Return safe default coordination decision"""
        return CoordinationDecision(
            mode=CoordinationMode.SYNCHRONIZED,  # Safest mode
            recommended_strategies=["basic"],     # Conservative strategies
            confidence=0.5,                      # Moderate confidence
            fallback=True,                       # Mark as fallback
            reason="Circuit breaker fallback",
            circuit_breaker_state=CircuitBreakerState.BREAKER_OPEN
        )

class EnhancedFallbackCoordinator:
    """[C-016] Multi-tier fallback strategies with Leyline integration"""

    def get_fallback_decision(self, state: SystemStatePacket, failure_reason: str) -> CoordinationDecision:
        """Tiered fallback based on failure type using Leyline SystemStatePacket"""

        if "timeout" in failure_reason.lower():
            # Fast timeout fallback - use cached decision
            return self._get_cached_fallback(state)

        elif "memory" in failure_reason.lower():
            # Memory pressure fallback - minimal processing
            return self._get_minimal_fallback(state)

        elif "compatibility" in failure_reason.lower():
            # Compatibility corruption fallback - conservative matrix
            return self._get_conservative_compatibility_fallback(state)

        else:
            # General fallback - synchronized mode
            return self._get_safe_synchronized_fallback(state)

    def _get_cached_fallback(self, state: SystemStatePacket) -> CoordinationDecision:
        """Use cached decision for fast fallback"""
        # Try to find similar cached decision
        cached_decision = self._lookup_similar_decision(state)
        if cached_decision:
            return CoordinationDecision(
                mode=cached_decision.mode,
                recommended_strategies=cached_decision.recommended_strategies,
                confidence=cached_decision.confidence * 0.8,  # Reduce confidence
                fallback=True,
                reason="Cached decision fallback",
                circuit_breaker_state=CircuitBreakerState.BREAKER_OPEN
            )

        return self._get_safe_synchronized_fallback(state)

    def _get_minimal_fallback(self, state: SystemStatePacket) -> CoordinationDecision:
        """Minimal processing fallback for memory pressure"""
        return CoordinationDecision(
            mode=CoordinationMode.SYNCHRONIZED,
            recommended_strategies=["basic"],
            confidence=0.6,
            fallback=True,
            conservative_mode=True,
            reason="Memory pressure fallback",
            circuit_breaker_state=CircuitBreakerState.BREAKER_OPEN
        )

    def _get_conservative_compatibility_fallback(self, state: SystemStatePacket) -> CoordinationDecision:
        """Conservative fallback when compatibility matrix corrupted"""

        # Extract curriculum stages from Leyline SystemStatePacket native map
        training_metrics = state.training_metrics
        task_stage = int(training_metrics.get("task_stage", 0))
        strategy_stage = int(training_metrics.get("strategy_stage", 0))

        # Use simple heuristic: if task and strategy stages are close, allow synchronization
        stage_diff = abs(task_stage - strategy_stage)

        if stage_diff <= 1:
            mode = CoordinationMode.SYNCHRONIZED
            strategies = ["basic", "simple"]
            confidence = 0.7
        else:
            mode = CoordinationMode.INDEPENDENT
            strategies = ["adaptive"]
            confidence = 0.5

        return CoordinationDecision(
            mode=mode,
            recommended_strategies=strategies,
            confidence=confidence,
            fallback=True,
            conservative_mode=True,
            reason="Compatibility corruption fallback",
            circuit_breaker_state=CircuitBreakerState.BREAKER_OPEN
        )

    def _get_safe_synchronized_fallback(self, state: SystemStatePacket) -> CoordinationDecision:
        """Safe synchronized fallback for general failures"""

        # Extract task stage from Leyline SystemStatePacket
        task_stage = int(state.training_metrics.get("task_stage", 0))

        return CoordinationDecision(
            mode=CoordinationMode.SYNCHRONIZED,
            recommended_strategies=["basic", "simple", "moderate"][:task_stage + 1],
            confidence=0.6,
            fallback=True,
            reason="General fallback coordination",
            circuit_breaker_state=CircuitBreakerState.BREAKER_OPEN
        )
```

### 1.3 Conservative Mode Management

```python
class ConservativeModeManager:
    """[C-016] Conservative mode state management with Leyline integration"""

    def __init__(self):
        self.active = False
        self.triggered_reasons = []
        self.activation_time = None
        self.performance_adjustments = {}
        self.recovery_threshold_met = False

    def activate(self, reason: str, adjustments: Dict[str, Any] = None):
        """Activate conservative mode with specific adjustments"""

        if not self.active:
            self.active = True
            self.activation_time = time.time()
            self.triggered_reasons.append(reason)

            # Apply performance adjustments
            default_adjustments = {
                "timing_budget_multiplier": 1.5,
                "cache_reduction_factor": 0.5,
                "complexity_reduction": 0.7,
                "fallback_probability": 0.3
            }

            self.performance_adjustments = {**default_adjustments, **(adjustments or {})}

            logging.warning(f"Conservative mode activated: {reason}")
            self._apply_adjustments()
            self._emit_conservative_mode_telemetry("activated", reason)

    def _emit_conservative_mode_telemetry(self, action: str, reason: str):
        """Emit conservative mode telemetry using Leyline TelemetryPacket"""

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_WARN,
            events=[
                TelemetryEvent(
                    event_name=f"conservative_mode_{action}",
                    severity=TelemetryLevel.TELEMETRY_WARN,
                    message=f"Conservative mode {action}: {reason}",
                    attributes={
                        "action": action,
                        "reason": reason,
                        "subsystem": "jace",
                        "active": str(self.active),
                        "duration_seconds": str(time.time() - self.activation_time) if self.activation_time else "0"
                    },
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        # Send via telemetry system
        self._send_telemetry_packet(telemetry_packet)

    def _apply_adjustments(self):
        """Apply conservative mode performance adjustments"""

        # Increase timing budgets
        timing_multiplier = self.performance_adjustments.get("timing_budget_multiplier", 1.5)
        # Implementation would adjust circuit breaker timeouts

        # Reduce cache utilization
        cache_reduction = self.performance_adjustments.get("cache_reduction_factor", 0.5)
        # Implementation would reduce cache sizes

        # Simplify coordination algorithms
        complexity_reduction = self.performance_adjustments.get("complexity_reduction", 0.7)
        # Implementation would disable advanced optimization features

    def check_recovery_conditions(self, metrics: Dict[str, float]) -> bool:
        """Check if conditions are met to exit conservative mode"""

        if not self.active:
            return True

        # Define recovery criteria
        recovery_criteria = {
            "coordination_success_rate": 0.95,
            "average_latency_ms": 15.0,
            "circuit_breaker_trips_per_hour": 1.0,
            "memory_utilization": 0.6
        }

        # Check all criteria
        recovery_met = True
        for metric_name, threshold in recovery_criteria.items():
            current_value = metrics.get(metric_name, 0)

            if metric_name in ["coordination_success_rate", "memory_utilization"]:
                # For these metrics, current should be better than threshold
                if current_value < threshold:
                    recovery_met = False
                    break
            else:
                # For these metrics, current should be less than threshold
                if current_value > threshold:
                    recovery_met = False
                    break

        if recovery_met and not self.recovery_threshold_met:
            self.recovery_threshold_met = True
            # Require sustained recovery for 5 minutes
            self.recovery_start_time = time.time()

        elif not recovery_met:
            self.recovery_threshold_met = False

        # Check if recovery has been sustained
        if self.recovery_threshold_met:
            recovery_duration = time.time() - self.recovery_start_time
            if recovery_duration >= 300:  # 5 minutes
                return True

        return False

    def deactivate(self, reason: str = "Recovery conditions met"):
        """Deactivate conservative mode"""

        if self.active:
            duration = time.time() - self.activation_time
            self.active = False
            self.activation_time = None
            self.recovery_threshold_met = False

            # Restore normal performance settings
            self._restore_normal_settings()

            logging.info(f"Conservative mode deactivated after {duration:.1f}s: {reason}")
            self._emit_conservative_mode_telemetry("deactivated", reason)

    def _restore_normal_settings(self):
        """Restore normal performance settings"""
        # Implementation would restore original timing budgets,
        # cache sizes, and algorithm complexity
        pass
```

## 2. Failure Detection Patterns

### 2.1 Performance-Based Detection

```python
class PerformanceFailureDetector:
    """Detect failures through performance degradation with Leyline telemetry"""

    def __init__(self):
        self.latency_history = deque(maxlen=100)
        self.error_rate_history = deque(maxlen=50)
        self.baseline_latency_ms = 18.0
        self.baseline_error_rate = 0.01

    def record_operation(self, latency_ms: float, success: bool):
        """Record operation performance"""

        self.latency_history.append(latency_ms)
        self.error_rate_history.append(0.0 if success else 1.0)

        # Check for failure patterns
        if self._detect_latency_spike():
            return FailureSignal(
                type="latency_spike",
                severity="high",
                confidence=0.9,
                details=f"Latency spike detected: {latency_ms}ms"
            )

        if self._detect_error_rate_increase():
            error_rate = sum(self.error_rate_history) / len(self.error_rate_history)
            return FailureSignal(
                type="error_rate_increase",
                severity="medium",
                confidence=0.8,
                details=f"Error rate increased to {error_rate:.2%}"
            )

        return None

    def _detect_latency_spike(self) -> bool:
        """Detect significant latency increase"""

        if len(self.latency_history) < 10:
            return False

        recent_avg = sum(list(self.latency_history)[-10:]) / 10
        return recent_avg > self.baseline_latency_ms * 3.0

    def _detect_error_rate_increase(self) -> bool:
        """Detect significant error rate increase"""

        if len(self.error_rate_history) < 20:
            return False

        recent_error_rate = sum(list(self.error_rate_history)[-20:]) / 20
        return recent_error_rate > self.baseline_error_rate * 5.0

@dataclass
class FailureSignal:
    """Signal indicating potential system failure"""
    type: str
    severity: str  # low, medium, high, critical
    confidence: float  # 0.0 to 1.0
    details: str
    timestamp: float = field(default_factory=time.time)

    def to_telemetry_event(self) -> TelemetryEvent:
        """Convert to Leyline TelemetryEvent"""

        severity_mapping = {
            "low": TelemetryLevel.TELEMETRY_INFO,
            "medium": TelemetryLevel.TELEMETRY_WARN,
            "high": TelemetryLevel.TELEMETRY_ERROR,
            "critical": TelemetryLevel.TELEMETRY_FATAL
        }

        return TelemetryEvent(
            event_name=f"failure_signal_{self.type}",
            severity=severity_mapping.get(self.severity, TelemetryLevel.TELEMETRY_WARN),
            message=f"Failure signal detected: {self.details}",
            attributes={
                "signal_type": self.type,
                "severity": self.severity,
                "confidence": str(self.confidence),
                "subsystem": "jace"
            },
            timestamp=google.protobuf.Timestamp()
        )
```

### 2.2 Resource-Based Detection

```python
class ResourceFailureDetector:
    """Detect failures through resource exhaustion with Leyline telemetry"""

    def __init__(self):
        self.memory_threshold_mb = 400  # Out of 512MB total
        self.cpu_threshold_percent = 80
        self.cache_hit_threshold = 0.5

    def check_resource_health(self, resources: Dict[str, float]) -> Optional[FailureSignal]:
        """Check resource utilization for failure indicators"""

        memory_mb = resources.get("memory_usage_mb", 0)
        cpu_percent = resources.get("cpu_usage_percent", 0)
        cache_hit_rate = resources.get("cache_hit_rate", 1.0)

        # Memory pressure detection
        if memory_mb > self.memory_threshold_mb:
            signal = FailureSignal(
                type="memory_pressure",
                severity="high",
                confidence=0.95,
                details=f"Memory usage {memory_mb}MB exceeds threshold {self.memory_threshold_mb}MB"
            )
            self._emit_resource_telemetry(signal)
            return signal

        # CPU overload detection
        if cpu_percent > self.cpu_threshold_percent:
            signal = FailureSignal(
                type="cpu_overload",
                severity="medium",
                confidence=0.8,
                details=f"CPU usage {cpu_percent}% exceeds threshold {self.cpu_threshold_percent}%"
            )
            self._emit_resource_telemetry(signal)
            return signal

        # Cache performance degradation
        if cache_hit_rate < self.cache_hit_threshold:
            signal = FailureSignal(
                type="cache_degradation",
                severity="low",
                confidence=0.7,
                details=f"Cache hit rate {cache_hit_rate:.2%} below threshold {self.cache_hit_threshold:.2%}"
            )
            self._emit_resource_telemetry(signal)
            return signal

        return None

    def _emit_resource_telemetry(self, signal: FailureSignal):
        """Emit resource failure signal via Leyline telemetry"""

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_WARN,
            events=[signal.to_telemetry_event()]
        )

        # Send via telemetry system
        self._send_telemetry_packet(telemetry_packet)
```

## 3. Recovery Procedures

### 3.1 Automatic Recovery

```python
class AutomaticRecoveryManager:
    """Manage automatic recovery from failures with Leyline integration"""

    def __init__(self):
        self.recovery_strategies = {
            "memory_pressure": self._recover_from_memory_pressure,
            "latency_spike": self._recover_from_latency_spike,
            "error_rate_increase": self._recover_from_error_rate,
            "cache_degradation": self._recover_from_cache_issues,
            "cpu_overload": self._recover_from_cpu_overload
        }

        self.recovery_history = []

    async def attempt_recovery(self, failure_signal: FailureSignal) -> bool:
        """Attempt automatic recovery based on failure type"""

        recovery_strategy = self.recovery_strategies.get(failure_signal.type)
        if not recovery_strategy:
            logging.warning(f"No recovery strategy for failure type: {failure_signal.type}")
            self._emit_recovery_telemetry("no_strategy", failure_signal)
            return False

        logging.info(f"Attempting recovery for {failure_signal.type}")
        self._emit_recovery_telemetry("attempting", failure_signal)

        try:
            success = await recovery_strategy(failure_signal)

            self.recovery_history.append({
                "failure_type": failure_signal.type,
                "timestamp": time.time(),
                "success": success,
                "details": failure_signal.details
            })

            self._emit_recovery_telemetry("completed" if success else "failed", failure_signal, {"success": success})
            return success

        except Exception as e:
            logging.error(f"Recovery attempt failed: {e}")
            self._emit_recovery_telemetry("exception", failure_signal, {"error": str(e)})
            return False

    def _emit_recovery_telemetry(self, status: str, failure_signal: FailureSignal, extra_attributes: Dict[str, Any] = None):
        """Emit recovery attempt telemetry via Leyline"""

        attributes = {
            "recovery_status": status,
            "failure_type": failure_signal.type,
            "failure_severity": failure_signal.severity,
            "subsystem": "jace"
        }
        if extra_attributes:
            attributes.update(extra_attributes)

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_INFO,
            events=[
                TelemetryEvent(
                    event_name=f"recovery_{status}",
                    severity=TelemetryLevel.TELEMETRY_INFO,
                    message=f"Recovery {status} for {failure_signal.type}: {failure_signal.details}",
                    attributes=attributes,
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        self._send_telemetry_packet(telemetry_packet)

    async def _recover_from_memory_pressure(self, signal: FailureSignal) -> bool:
        """Recover from memory pressure"""

        # Force garbage collection
        gc.collect()

        # Clear non-essential caches
        # Implementation would clear L3 cache, reduce L2 cache size

        # Enable conservative mode
        # Implementation would trigger conservative mode

        # Wait and check if memory pressure reduced
        await asyncio.sleep(2)

        # Check memory usage after cleanup
        current_memory = psutil.Process().memory_info().rss / 1024 / 1024
        return current_memory < 400  # MB

    async def _recover_from_latency_spike(self, signal: FailureSignal) -> bool:
        """Recover from latency spikes"""

        # Switch to faster algorithms
        # Implementation would disable complex optimization

        # Increase timeout budgets temporarily
        # Implementation would extend circuit breaker timeouts

        # Reduce workload complexity
        # Implementation would limit trajectory length

        return True  # Optimistic recovery

    async def _recover_from_error_rate(self, signal: FailureSignal) -> bool:
        """Recover from increased error rates"""

        # Increase validation and defensive programming
        # Implementation would enable additional bounds checking

        # Switch to more conservative algorithms
        # Implementation would use fallback coordinator

        # Reset any corrupted state
        # Implementation would clear dynamic caches

        return True

    async def _recover_from_cache_issues(self, signal: FailureSignal) -> bool:
        """Recover from cache performance issues"""

        # Rebuild caches with fresh data
        # Implementation would clear and warm caches

        # Adjust cache sizing
        # Implementation would optimize cache parameters

        return True

    async def _recover_from_cpu_overload(self, signal: FailureSignal) -> bool:
        """Recover from CPU overload"""

        # Reduce computational complexity
        # Implementation would use simpler algorithms

        # Increase processing intervals
        # Implementation would reduce update frequency

        return True
```

### 3.2 Manual Recovery Procedures

```python
class ManualRecoveryProcedures:
    """Documented manual recovery procedures for operations"""

    @staticmethod
    def circuit_breaker_stuck_open():
        """Manual procedure for stuck open circuit breaker"""
        return """
        MANUAL RECOVERY: Circuit Breaker Stuck Open

        1. Check system logs for root cause of failures
        2. Verify external dependencies (Tamiyo, Simic) are healthy via Leyline SystemStatePacket
        3. If dependencies recovered, manually reset circuit breaker:
           - Access Jace admin endpoint: /admin/circuit-breaker/reset
           - Or restart Jace service to reset state
        4. Monitor coordination success rate for 10 minutes
        5. Verify Leyline telemetry shows normal operation
        6. If issues persist, escalate to system architect
        """

    @staticmethod
    def conservative_mode_stuck():
        """Manual procedure for conservative mode not recovering"""
        return """
        MANUAL RECOVERY: Conservative Mode Stuck Active

        1. Check performance metrics meet recovery criteria:
           - Coordination success rate > 95%
           - Average latency < 15ms
           - Memory usage < 60%
        2. Verify Leyline telemetry shows healthy system state
        3. If metrics are healthy, manually deactivate:
           - Access: /admin/conservative-mode/deactivate
        4. Monitor for 30 minutes to ensure stable operation
        5. If conservative mode reactivates immediately, investigate:
           - Check SLO error budgets
           - Verify resource utilization
           - Review recent failure patterns in Leyline telemetry
        """

    @staticmethod
    def memory_leak_suspected():
        """Manual procedure for suspected memory leaks"""
        return """
        MANUAL RECOVERY: Memory Leak Suspected

        1. Capture memory profile: /admin/memory/profile
        2. Force garbage collection: /admin/memory/gc
        3. Check cache sizes and TTL settings
        4. Review Leyline telemetry for memory pressure events
        5. If memory continues growing:
           - Restart Jace service (graceful shutdown)
           - Monitor memory growth rate post-restart
        6. If leak persists after restart:
           - Escalate with memory profile data and Leyline telemetry
           - Consider reducing cache sizes as temporary mitigation
        """

    @staticmethod
    def leyline_integration_failure():
        """Manual procedure for Leyline integration failures"""
        return """
        MANUAL RECOVERY: Leyline Integration Failure

        1. Verify Leyline shared contracts version compatibility
        2. Check message serialization/deserialization:
           - Test SystemStatePacket creation and parsing
           - Validate TelemetryPacket transmission
        3. Monitor message size limits (280-byte target)
        4. Check circuit breaker states using Leyline enum values
        5. If serialization fails:
           - Verify protobuf version compatibility
           - Check for schema version mismatches
        6. If coordination fails:
           - Switch to fallback mode with basic coordination
           - Log all failures via Leyline telemetry
           - Escalate with complete telemetry data
        """
```

## 4. Integration Contract

### 4.1 Circuit Breaker Interface

The circuit breaker system provides standardized interfaces for:

- **Protected Function Execution**: `circuit_breaker.call(func, *args, **kwargs)`
- **State Monitoring**: `circuit_breaker.get_state()` returns Leyline CircuitBreakerState enum
- **Manual Control**: `circuit_breaker.force_open()`, `circuit_breaker.force_closed()`
- **Metrics Integration**: Circuit breaker metrics exported to Prometheus and Leyline telemetry

### 4.2 Fallback Coordinator Interface

- **Primary Fallback**: `get_safe_decision()` - Standard fallback coordination
- **Contextual Fallback**: `get_fallback_decision(state, reason)` - Context-aware fallback using SystemStatePacket
- **Cached Fallback**: `get_cached_decision(state)` - Fast cached decision lookup with SystemStatePacket
- **Emergency Fallback**: `get_emergency_decision()` - Last resort coordination

### 4.3 Conservative Mode Integration

- **Activation Triggers**: SLO violations, circuit breaker trips, resource pressure
- **Performance Adjustments**: Timing budgets, cache sizes, algorithm complexity
- **Recovery Monitoring**: Automated recovery condition checking
- **Manual Override**: Administrative controls for mode management
- **Leyline Telemetry**: All conservative mode events reported via TelemetryPacket

### 4.4 Leyline Integration Points

- **Circuit Breaker States**: Use CircuitBreakerState enum from Leyline
- **Safety Violations**: Report via TelemetryPacket with SafetyViolation events
- **Failure Detection**: Consume SystemStatePacket for health monitoring
- **Recovery Telemetry**: All recovery attempts logged via Leyline telemetry
- **Cross-Subsystem Communication**: AdaptationCommand for emergency coordination

## 5. References

**Back to Main Document**: [11-jace-unified-design.md](11-jace-unified-design.md) - Core architecture and system overview
**Related Components**:
- [11.1-jace-testing-frameworks.md](11.1-jace-testing-frameworks.md) - Chaos engineering tests that validate circuit breaker behavior
- [11.3-jace-slo-framework.md](11.3-jace-slo-framework.md) - SLO monitoring that triggers conservative mode

**Leyline Integration**:
- Leyline Shared Contracts: 00-leyline-shared-contracts.md - Complete shared contract specifications
- C-018 Round 7 Consensus: Option B (Performance-First) implementation requirements

**External References**:
- Circuit Breaker Pattern - Martin Fowler
- Release It! - Michael Nygard (Stability Patterns)
- Building Microservices - Sam Newman (Resilience Engineering)
- C-016 External Review - Circuit Breaker Requirements