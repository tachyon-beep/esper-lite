# Nissa Mission Control Design

## Document Metadata

| Field | Value |
|-------|-------|
| Parent Document | [10 - Nissa Unified Design](10-nissa-unified-design.md) |
| Component Type | Observability - Mission Control Interface |
| Version | 3.0 |
| Status | Production Ready with C-016 Enhancements |
| Date | 2025-09-10 |
| Author | System Architecture Team |

---

## Overview

This document details the Mission Control subsystem of Nissa, providing operational control interfaces, API services, real-time WebSocket communication, and dashboard configurations. Mission Control serves as the primary interface for operators to monitor and control the morphogenetic training system.

### Key Capabilities

- **REST/GraphQL API** for programmatic access
- **WebSocket Gateway** for real-time updates and bidirectional communication
- **Dashboard Framework** for visualization and control
- **Analytics Engine** for historical analysis and insights
- **Operational Controls** for system management

## Technical Design

### Mission Control Core Architecture

```python
class MissionControlCore:
    """Central operational control system for Nissa"""

    def __init__(self):
        # API Services
        self.rest_api = RESTAPIServer()
        self.graphql_api = GraphQLServer()
        self.websocket_gateway = WebSocketGateway()

        # Dashboard Services
        self.dashboard_manager = DashboardManager()
        self.widget_registry = WidgetRegistry()
        self.layout_engine = LayoutEngine()

        # Analytics Services
        self.analytics_engine = AnalyticsEngine()
        self.report_generator = ReportGenerator()
        self.anomaly_detector = AnomalyDetector()

        # Control Services
        self.command_executor = CommandExecutor()
        self.configuration_manager = ConfigurationManager()
        self.rollback_controller = RollbackController()

        # Security Layer
        self.auth_manager = AuthenticationManager()
        self.authz_manager = AuthorizationManager()
        self.audit_logger = AuditLogger()

        # Circuit Breaker Protection
        self.circuit_breaker = ObservabilityCircuitBreaker(
            CircuitBreakerConfig(), "mission_control"
        )
```

### API Server Implementation

#### REST API

```python
class RESTAPIServer:
    """RESTful API for Mission Control operations"""

    def __init__(self):
        self.app = FastAPI(title="Nissa Mission Control API")
        self.router = APIRouter()

        # Circuit breaker for API operations
        self.circuit_breaker = ObservabilityCircuitBreaker(
            CircuitBreakerConfig(), "rest_api"
        )

        # Rate limiting
        self.rate_limiter = RateLimiter(
            requests_per_minute=1000,
            burst_size=100
        )

        self._setup_routes()

    def _setup_routes(self):
        """Configure API routes"""

        @self.router.get("/metrics/query")
        async def query_metrics(
            query: str,
            start_time: int,
            end_time: int,
            resolution: str = "auto"
        ):
            """Query metrics with time range and resolution"""
            return await self.circuit_breaker.execute_with_protection(
                self._query_metrics_internal,
                "query_metrics",
                query, start_time, end_time, resolution
            )

        @self.router.get("/events/stream")
        async def stream_events(
            filter: Optional[str] = None,
            since: Optional[int] = None
        ):
            """Stream events with optional filtering"""
            return await self.circuit_breaker.execute_with_protection(
                self._stream_events_internal,
                "stream_events",
                filter, since
            )

        @self.router.post("/control/execute")
        async def execute_command(
            command: ControlCommand,
            dry_run: bool = False
        ):
            """Execute control command with optional dry run"""
            return await self.circuit_breaker.execute_with_protection(
                self._execute_command_internal,
                "execute_command",
                command, dry_run
            )

        @self.router.get("/system/health")
        async def get_system_health():
            """Get comprehensive system health status"""
            return await self._get_system_health()

        @self.router.get("/dashboards/list")
        async def list_dashboards(
            user_id: Optional[str] = None
        ):
            """List available dashboards for user"""
            return await self._list_dashboards(user_id)

        @self.router.post("/alerts/acknowledge")
        async def acknowledge_alert(
            alert_id: str,
            acknowledgment: AlertAcknowledgment
        ):
            """Acknowledge an active alert"""
            return await self._acknowledge_alert(alert_id, acknowledgment)
```

#### GraphQL API

```python
class GraphQLServer:
    """GraphQL API for flexible querying"""

    def __init__(self):
        self.schema = self._build_schema()

        # Circuit breaker for GraphQL operations
        self.circuit_breaker = ObservabilityCircuitBreaker(
            CircuitBreakerConfig(), "graphql_api"
        )

    def _build_schema(self):
        """Build GraphQL schema"""

        type_defs = """
        type Query {
            metrics(
                query: String!
                timeRange: TimeRange!
                resolution: String
            ): MetricsResult

            events(
                filter: EventFilter
                pagination: Pagination
            ): EventsResult

            systemStatus: SystemStatus

            dashboards(
                userId: ID
            ): [Dashboard]

            alerts(
                status: AlertStatus
                severity: AlertSeverity
            ): [Alert]
        }

        type Mutation {
            executeCommand(
                command: CommandInput!
                dryRun: Boolean
            ): CommandResult

            acknowledgeAlert(
                alertId: ID!
                message: String
            ): Alert

            createDashboard(
                dashboard: DashboardInput!
            ): Dashboard

            updateConfiguration(
                config: ConfigurationInput!
            ): Configuration
        }

        type Subscription {
            metricsStream(
                queries: [String!]!
            ): MetricPoint

            eventStream(
                filter: EventFilter
            ): Event

            alertStream(
                severity: AlertSeverity
            ): Alert

            systemHealthStream: SystemHealth
        }
        """

        return make_executable_schema(type_defs, self.resolvers)
```

### WebSocket Gateway

Real-time bidirectional communication:

```python
class WebSocketGateway:
    """WebSocket gateway for real-time updates"""

    def __init__(self):
        self.connections: Dict[str, WebSocketConnection] = {}
        self.subscriptions: Dict[str, List[Subscription]] = {}
        self.max_connections = 10_000

        # Circuit breaker for WebSocket operations
        self.circuit_breaker = ObservabilityCircuitBreaker(
            CircuitBreakerConfig(), "websocket_gateway"
        )

        # Connection limiter
        self.connection_limiter = ConnectionLimiter(
            max_connections=self.max_connections,
            max_per_ip=100
        )

    async def handle_connection(self, websocket: WebSocket, client_id: str):
        """Handle new WebSocket connection"""

        # Check connection limits
        if not await self.connection_limiter.can_connect(client_id):
            await websocket.close(code=1008, reason="Connection limit exceeded")
            return

        # Accept connection
        await websocket.accept()

        # Store connection
        connection = WebSocketConnection(
            websocket=websocket,
            client_id=client_id,
            connected_at=time.time()
        )
        self.connections[client_id] = connection

        try:
            # Handle messages
            async for message in websocket.iter_json():
                await self.handle_message(connection, message)

        except WebSocketDisconnect:
            await self.handle_disconnect(connection)

        finally:
            # Clean up connection
            self.connections.pop(client_id, None)
            await self.cleanup_subscriptions(client_id)

    async def handle_message(self, connection: WebSocketConnection, message: Dict):
        """Process WebSocket message"""

        message_type = message.get("type")

        if message_type == "subscribe":
            await self.handle_subscription(connection, message)

        elif message_type == "unsubscribe":
            await self.handle_unsubscription(connection, message)

        elif message_type == "command":
            await self.handle_command(connection, message)

        elif message_type == "ping":
            await connection.websocket.send_json({"type": "pong"})

        else:
            await connection.websocket.send_json({
                "type": "error",
                "message": f"Unknown message type: {message_type}"
            })

    async def broadcast_update(self, channel: str, data: Dict):
        """Broadcast update to all subscribers"""

        subscribers = self.subscriptions.get(channel, [])

        for subscription in subscribers:
            connection = self.connections.get(subscription.client_id)
            if connection:
                try:
                    await connection.websocket.send_json({
                        "type": "update",
                        "channel": channel,
                        "data": data,
                        "timestamp": time.time()
                    })
                except Exception as e:
                    logging.error(f"Failed to send update to {subscription.client_id}: {e}")
```

### Dashboard Framework

Flexible dashboard configuration and management:

```python
class DashboardManager:
    """Dashboard configuration and management"""

    def __init__(self):
        self.dashboards: Dict[str, Dashboard] = {}
        self.templates: Dict[str, DashboardTemplate] = {}

        # Default dashboard configurations
        self._load_default_dashboards()

    def _load_default_dashboards(self):
        """Load default dashboard configurations"""

        # System Overview Dashboard
        self.templates["system_overview"] = DashboardTemplate(
            name="System Overview",
            layout="grid",
            widgets=[
                {
                    "type": "metric",
                    "title": "Training Progress",
                    "query": "training_epoch",
                    "visualization": "gauge"
                },
                {
                    "type": "timeseries",
                    "title": "Loss Curve",
                    "queries": ["training_loss", "validation_loss"],
                    "visualization": "line"
                },
                {
                    "type": "heatmap",
                    "title": "Seed Activity",
                    "query": "seed_activity_matrix",
                    "visualization": "heatmap"
                },
                {
                    "type": "log",
                    "title": "Recent Events",
                    "filter": "level:info OR level:warning",
                    "limit": 100
                }
            ]
        )

        # Performance Dashboard
        self.templates["performance"] = DashboardTemplate(
            name="Performance Monitoring",
            layout="flex",
            widgets=[
                {
                    "type": "timeseries",
                    "title": "Throughput",
                    "queries": [
                        "events_per_second",
                        "metrics_per_second"
                    ],
                    "visualization": "area"
                },
                {
                    "type": "histogram",
                    "title": "Latency Distribution",
                    "query": "request_latency_histogram",
                    "visualization": "histogram"
                },
                {
                    "type": "metric",
                    "title": "P99 Latency",
                    "query": "request_latency_p99",
                    "visualization": "number",
                    "thresholds": {
                        "warning": 100,
                        "critical": 150
                    }
                }
            ]
        )

        # Control Panel Dashboard
        self.templates["control_panel"] = DashboardTemplate(
            name="Control Panel",
            layout="tabs",
            widgets=[
                {
                    "type": "control",
                    "title": "Training Control",
                    "controls": [
                        {"type": "button", "action": "pause_training", "label": "Pause"},
                        {"type": "button", "action": "resume_training", "label": "Resume"},
                        {"type": "slider", "action": "set_learning_rate", "min": 0.0001, "max": 0.1}
                    ]
                },
                {
                    "type": "status",
                    "title": "System Status",
                    "indicators": [
                        {"name": "Circuit Breakers", "query": "circuit_breaker_status"},
                        {"name": "Conservative Mode", "query": "conservative_mode_active"},
                        {"name": "Memory Usage", "query": "memory_usage_percent"}
                    ]
                }
            ]
        )

    async def create_dashboard(self, config: DashboardConfig) -> Dashboard:
        """Create new dashboard from configuration"""

        dashboard = Dashboard(
            id=generate_id(),
            name=config.name,
            owner=config.owner,
            layout=config.layout,
            widgets=[]
        )

        # Initialize widgets
        for widget_config in config.widgets:
            widget = await self.create_widget(widget_config)
            dashboard.widgets.append(widget)

        self.dashboards[dashboard.id] = dashboard
        return dashboard
```

### Analytics Engine

Historical analysis and insights:

```python
class AnalyticsEngine:
    """Analytics engine for historical analysis"""

    def __init__(self):
        self.query_engine = QueryEngine()
        self.aggregator = DataAggregator()
        self.statistical_analyzer = StatisticalAnalyzer()
        self.ml_analyzer = MLAnalyzer()

        # Circuit breaker for analytics operations
        self.circuit_breaker = ObservabilityCircuitBreaker(
            CircuitBreakerConfig(), "analytics_engine"
        )

    async def analyze_performance_trends(
        self,
        metric: str,
        time_range: TimeRange,
        granularity: str = "1h"
    ) -> PerformanceAnalysis:
        """Analyze performance trends over time"""

        # Fetch historical data
        data = await self.query_engine.query_time_series(
            metric,
            time_range,
            granularity
        )

        # Calculate statistics
        stats = self.statistical_analyzer.calculate_statistics(data)

        # Detect trends
        trends = self.ml_analyzer.detect_trends(data)

        # Identify anomalies
        anomalies = self.ml_analyzer.detect_anomalies(data)

        return PerformanceAnalysis(
            metric=metric,
            statistics=stats,
            trends=trends,
            anomalies=anomalies,
            recommendations=self._generate_recommendations(stats, trends)
        )

    async def generate_report(
        self,
        report_type: str,
        time_range: TimeRange,
        filters: Optional[Dict] = None
    ) -> Report:
        """Generate analytical report"""

        report = Report(
            type=report_type,
            time_range=time_range,
            generated_at=time.time()
        )

        if report_type == "system_health":
            report.sections = await self._generate_health_report(time_range)

        elif report_type == "performance":
            report.sections = await self._generate_performance_report(time_range)

        elif report_type == "training_progress":
            report.sections = await self._generate_training_report(time_range)

        elif report_type == "incident":
            report.sections = await self._generate_incident_report(time_range, filters)

        return report
```

### Operational Control Interfaces

System control and management:

```python
class CommandExecutor:
    """Execute operational control commands"""

    def __init__(self):
        self.command_registry = CommandRegistry()
        self.validation_engine = CommandValidator()
        self.rollback_manager = RollbackManager()

        # Circuit breaker for command execution
        self.circuit_breaker = ObservabilityCircuitBreaker(
            CircuitBreakerConfig(), "command_executor"
        )

    async def execute_command(
        self,
        command: ControlCommand,
        dry_run: bool = False
    ) -> CommandResult:
        """Execute control command with optional dry run"""

        # Validate command
        validation_result = await self.validation_engine.validate(command)
        if not validation_result.is_valid:
            return CommandResult(
                status="validation_failed",
                errors=validation_result.errors
            )

        # Check authorization
        if not await self._check_authorization(command):
            return CommandResult(
                status="unauthorized",
                errors=["Insufficient permissions"]
            )

        # Dry run mode
        if dry_run:
            return await self._simulate_command(command)

        # Execute with rollback support
        try:
            # Create rollback point
            rollback_id = await self.rollback_manager.create_checkpoint()

            # Execute command
            result = await self.circuit_breaker.execute_with_protection(
                self._execute_command_internal,
                "execute_command",
                command
            )

            # Verify success
            if result.status == "success":
                await self.rollback_manager.commit_checkpoint(rollback_id)
            else:
                await self.rollback_manager.rollback_to_checkpoint(rollback_id)

            return result

        except Exception as e:
            # Automatic rollback on failure
            await self.rollback_manager.rollback_to_checkpoint(rollback_id)
            return CommandResult(
                status="execution_failed",
                errors=[str(e)]
            )

    async def _execute_command_internal(
        self,
        command: ControlCommand
    ) -> CommandResult:
        """Internal command execution"""

        handler = self.command_registry.get_handler(command.type)
        if not handler:
            return CommandResult(
                status="unknown_command",
                errors=[f"No handler for command type: {command.type}"]
            )

        return await handler.execute(command)
```

## User Interface Components

### Widget Registry

Available dashboard widgets:

```python
class WidgetRegistry:
    """Registry of available dashboard widgets"""

    def __init__(self):
        self.widgets = {
            "metric": MetricWidget,
            "timeseries": TimeSeriesWidget,
            "histogram": HistogramWidget,
            "heatmap": HeatmapWidget,
            "log": LogWidget,
            "status": StatusWidget,
            "control": ControlWidget,
            "alert": AlertWidget,
            "table": TableWidget,
            "text": TextWidget
        }

    def create_widget(self, widget_type: str, config: Dict) -> Widget:
        """Create widget instance from configuration"""

        widget_class = self.widgets.get(widget_type)
        if not widget_class:
            raise ValueError(f"Unknown widget type: {widget_type}")

        return widget_class(**config)
```

### Layout Engine

Dashboard layout management:

```python
class LayoutEngine:
    """Dashboard layout engine"""

    def __init__(self):
        self.layout_strategies = {
            "grid": GridLayout,
            "flex": FlexLayout,
            "tabs": TabLayout,
            "split": SplitLayout
        }

    def render_layout(
        self,
        layout_type: str,
        widgets: List[Widget],
        viewport: Viewport
    ) -> RenderedLayout:
        """Render dashboard layout"""

        strategy = self.layout_strategies.get(layout_type)
        if not strategy:
            raise ValueError(f"Unknown layout type: {layout_type}")

        return strategy.render(widgets, viewport)
```

## Security and Access Control

### Authentication and Authorization

```python
class EnhancedSecurityLayer:
    """Comprehensive security with C-016 circuit breaker protection"""

    def __init__(self):
        self.auth_manager = AuthenticationManager()
        self.authz_manager = AuthorizationManager()
        self.audit_logger = AuditLogger()

        # Circuit breaker for auth operations
        self.circuit_breaker = ObservabilityCircuitBreaker(
            CircuitBreakerConfig(failure_threshold=3), "security_layer"
        )

        # Memory management for auth sessions
        self.memory_manager = MemoryManager()

        # Enhanced role-based access control
        self.roles = {
            "viewer": [
                "read:metrics", "read:events", "read:dashboards"
            ],
            "operator": [
                "viewer", "execute:control", "acknowledge:alerts",
                "trigger:conservative_mode"
            ],
            "admin": [
                "operator", "configure:system", "manage:users",
                "override:circuit_breakers", "access:emergency_controls"
            ]
        }

    async def authenticate_request(self, request: Request) -> Dict[str, Any]:
        """Authenticate with circuit breaker protection"""

        return self.circuit_breaker.execute_with_protection(
            self._authenticate_request_internal,
            "authenticate_request",
            request
        )

    async def _authenticate_request_internal(self, request: Request) -> Dict[str, Any]:
        """Internal authentication with C-016 enhancements"""

        token = request.headers.get("Authorization")
        if not token:
            raise AuthenticationError("Missing authentication token")

        user = await self.auth_manager.verify_token(token)

        # Store authenticated session with TTL
        await self.memory_manager.store_with_ttl(
            "auth_session",
            int(time.time() / 3600),  # hour-based epoch
            user.session_id,
            {
                "user_id": user.id,
                "roles": user.roles,
                "authenticated_at": time.time()
            },
            custom_ttl_ms=3_600_000  # 1 hour session TTL
        )

        # Log access with circuit breaker protection
        await self.circuit_breaker.execute_with_protection(
            self.audit_logger.log_access,
            "log_access",
            user,
            request
        )

        return {
            "status": "authenticated",
            "user": user,
            "session_expires_ms": 3_600_000
        }
```

## Performance Characteristics

### API Performance

- **REST API latency P99**: 50ms
- **GraphQL query latency P99**: 100ms
- **WebSocket message latency**: <10ms
- **Maximum concurrent connections**: 10,000
- **Request rate limit**: 1,000 requests/minute

### Dashboard Performance

- **Widget render time**: <100ms
- **Dashboard load time**: <500ms
- **Real-time update frequency**: 1Hz - 10Hz
- **Maximum widgets per dashboard**: 50

## Related Documentation

- [10 - Nissa Unified Design](10-nissa-unified-design.md)
- [10.1 - Nissa Metrics and Telemetry Design](10.1-nissa-metrics-telemetry.md)
- [10.3 - Nissa Alerting and SLO Design](10.3-nissa-alerting-slo.md)
- [09 - Oona Message Bus Design](09-oona-unified-design.md)