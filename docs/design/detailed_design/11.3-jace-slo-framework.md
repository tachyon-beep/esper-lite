# Jace - SLO Framework and Error Budgets

**Parent Document**: [11-jace-unified-design.md](11-jace-unified-design.md)
**Component Type**: Performance Framework
**Version**: 3.0
**Leyline Integration**: COMPLETE - Integrated with Leyline (shared contracts) per Option B

---

## Overview

This document specifies the comprehensive Service Level Objective (SLO) framework for Jace curriculum coordination, including error budget management, performance monitoring, and automated conservative mode activation. The SLO framework ensures coordination performance meets production requirements while providing early warning of degradation. All performance monitoring integrates with Leyline (shared contracts) for consistent cross-subsystem telemetry.

## 1. Service Level Objectives

### 1.1 SLO Definitions

```python
from typing import Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum
import time
import logging

# Import from Leyline (shared contracts)
from esper.leyline.contracts import (
    SystemStatePacket,
    TelemetryPacket,
    TelemetryEvent,
    TelemetryLevel,
    MetricPoint,
    MetricType,
    HealthStatus,
    CircuitBreakerState
)
from esper.leyline.version import SchemaVersion

@dataclass
class SLOTarget:
    """SLO definition with error budget"""
    name: str
    target_percentile: int  # e.g., 95 for p95
    target_value_ms: float
    error_budget_percent: float  # e.g., 1.0 for 1%
    measurement_window_hours: int = 24

class SLOStatus(Enum):
    HEALTHY = "healthy"           # Within SLO targets
    WARNING = "warning"           # Approaching error budget
    CRITICAL = "critical"         # Error budget exceeded
    EMERGENCY = "emergency"       # Severe SLO violations

class JaceSLOManager:
    """[C-016] SLO tracking with error budgets and conservative mode triggers via Leyline"""

    def __init__(self):
        # Core SLO definitions
        self.slos = {
            "coordination_latency": SLOTarget(
                name="coordination_latency",
                target_percentile=95,
                target_value_ms=18.0,  # Realistic 18ms timing from Leyline PerformanceBudgets
                error_budget_percent=0.1,  # 0.1% error budget
                measurement_window_hours=24
            ),
            "coordination_success_rate": SLOTarget(
                name="coordination_success_rate",
                target_percentile=100,
                target_value_ms=90.0,  # 90% success rate (expressed as percentage)
                error_budget_percent=1.0,
                measurement_window_hours=24
            ),
            "fallback_rate": SLOTarget(
                name="fallback_rate",
                target_percentile=100,
                target_value_ms=5.0,  # Max 5% fallback rate
                error_budget_percent=0.5,
                measurement_window_hours=24
            )
        }

        # SLO tracking state
        self.measurements: Dict[str, List[Dict[str, Any]]] = {}
        self.error_budget_consumed: Dict[str, float] = {}
        self.conservative_mode_active = False
        self.last_budget_check = time.time()

        # Initialize measurement storage
        for slo_name in self.slos:
            self.measurements[slo_name] = []
            self.error_budget_consumed[slo_name] = 0.0

    def record_coordination_latency(self, latency_ms: float):
        """Record coordination latency measurement with Leyline telemetry"""
        self._record_measurement("coordination_latency", latency_ms)

        # Emit metric via Leyline TelemetryPacket
        self._emit_slo_metric("coordination_latency_ms", latency_ms, MetricType.METRIC_GAUGE)

        # Check for immediate SLO violation
        if latency_ms > self.slos["coordination_latency"].target_value_ms:
            self._handle_slo_violation("coordination_latency", latency_ms)

    def record_coordination_result(self, success: bool, fallback: bool):
        """Record coordination success/failure with Leyline telemetry"""

        # Success rate (100 = 100%, 0 = 0%)
        success_rate = 100.0 if success else 0.0
        self._record_measurement("coordination_success_rate", success_rate)
        self._emit_slo_metric("coordination_success_rate", success_rate, MetricType.METRIC_GAUGE)

        # Fallback rate (100 = 100% fallback, 0 = 0% fallback)
        fallback_rate = 100.0 if fallback else 0.0
        self._record_measurement("fallback_rate", fallback_rate)
        self._emit_slo_metric("coordination_fallback_rate", fallback_rate, MetricType.METRIC_GAUGE)

        if not success:
            self._handle_slo_violation("coordination_success_rate", 0.0)
        if fallback:
            self._handle_slo_violation("fallback_rate", 100.0)

    def _emit_slo_metric(self, metric_name: str, value: float, metric_type: MetricType):
        """Emit SLO metric via Leyline TelemetryPacket"""

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_INFO,
            metrics=[
                MetricPoint(
                    name=metric_name,
                    value=value,
                    type=metric_type,
                    labels={
                        "subsystem": "jace",
                        "component": "slo_manager"
                    },
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        self._send_telemetry_packet(telemetry_packet)
```

### 1.2 SLO Measurement and Tracking

```python
def _record_measurement(self, slo_name: str, value: float):
    """Record SLO measurement with TTL"""

    measurement = {
        "timestamp": time.time(),
        "value": value
    }

    self.measurements[slo_name].append(measurement)

    # Cleanup old measurements (keep within window)
    window_seconds = self.slos[slo_name].measurement_window_hours * 3600
    cutoff_time = time.time() - window_seconds

    self.measurements[slo_name] = [
        m for m in self.measurements[slo_name]
        if m["timestamp"] > cutoff_time
    ]

def _handle_slo_violation(self, slo_name: str, violating_value: float):
    """Handle SLO violation and update error budget with Leyline telemetry"""

    slo = self.slos[slo_name]

    # Calculate error budget consumption
    violation_weight = self._calculate_violation_weight(slo_name, violating_value)
    self.error_budget_consumed[slo_name] += violation_weight

    # Check if error budget is exhausted
    budget_exhausted = self.error_budget_consumed[slo_name] > slo.error_budget_percent

    if budget_exhausted and not self.conservative_mode_active:
        self._trigger_conservative_mode(f"SLO {slo_name} error budget exhausted")

    # Emit SLO violation event via Leyline
    self._emit_slo_violation_event(slo_name, violating_value, violation_weight)

    logging.warning(
        f"SLO violation: {slo_name}={violating_value}, "
        f"target={slo.target_value_ms}, "
        f"budget_consumed={self.error_budget_consumed[slo_name]}%"
    )

def _emit_slo_violation_event(self, slo_name: str, violating_value: float, violation_weight: float):
    """Emit SLO violation event via Leyline telemetry"""

    slo = self.slos[slo_name]
    severity = TelemetryLevel.TELEMETRY_ERROR if violation_weight > 0.5 else TelemetryLevel.TELEMETRY_WARN

    telemetry_packet = TelemetryPacket(
        packet_id=str(uuid.uuid4()),
        timestamp=google.protobuf.Timestamp(),
        source_subsystem="jace",
        level=severity,
        events=[
            TelemetryEvent(
                event_name="slo_violation",
                severity=severity,
                message=f"SLO violation detected: {slo_name}",
                attributes={
                    "slo_name": slo_name,
                    "violating_value": str(violating_value),
                    "target_value": str(slo.target_value_ms),
                    "violation_weight": str(violation_weight),
                    "budget_consumed": str(self.error_budget_consumed[slo_name]),
                    "budget_limit": str(slo.error_budget_percent),
                    "subsystem": "jace"
                },
                timestamp=google.protobuf.Timestamp()
            )
        ]
    )

    self._send_telemetry_packet(telemetry_packet)

def _calculate_violation_weight(self, slo_name: str, violating_value: float) -> float:
    """Calculate error budget consumption weight for violation"""

    slo = self.slos[slo_name]

    if slo_name == "coordination_latency":
        # Weight by how much we exceeded target
        excess_ratio = violating_value / slo.target_value_ms
        return min(excess_ratio - 1.0, 1.0)  # Cap at 100% consumption per violation

    elif slo_name == "coordination_success_rate":
        # Failure consumes fixed budget
        return 0.1  # Each failure = 0.1% budget

    elif slo_name == "fallback_rate":
        # Fallback consumes proportional budget
        return 0.05  # Each fallback = 0.05% budget

    return 0.1  # Default weight
```

## 2. Error Budget Management

### 2.1 Error Budget Calculations

```python
class ErrorBudgetManager:
    """Manage error budgets and consumption tracking with Leyline telemetry"""

    def __init__(self, slo_manager: JaceSLOManager):
        self.slo_manager = slo_manager
        self.budget_reset_times = {}

    def get_error_budget_status(self) -> Dict[str, Any]:
        """Get current error budget status for all SLOs with Leyline telemetry"""

        status = {}

        for slo_name, slo in self.slo_manager.slos.items():
            consumed = self.slo_manager.error_budget_consumed.get(slo_name, 0.0)
            remaining = max(0.0, slo.error_budget_percent - consumed)
            utilization = consumed / slo.error_budget_percent if slo.error_budget_percent > 0 else 0.0

            # Calculate burn rate (budget consumed per hour)
            burn_rate = self._calculate_burn_rate(slo_name)

            # Estimate time to budget exhaustion
            time_to_exhaustion_hours = None
            if burn_rate > 0 and remaining > 0:
                time_to_exhaustion_hours = remaining / burn_rate

            slo_status = {
                "budget_percent": slo.error_budget_percent,
                "consumed_percent": consumed,
                "remaining_percent": remaining,
                "utilization": utilization,
                "burn_rate_per_hour": burn_rate,
                "time_to_exhaustion_hours": time_to_exhaustion_hours,
                "status": self._get_budget_status(utilization)
            }

            status[slo_name] = slo_status

            # Emit budget utilization metric via Leyline
            self._emit_budget_utilization_metric(slo_name, utilization, burn_rate)

        return status

    def _emit_budget_utilization_metric(self, slo_name: str, utilization: float, burn_rate: float):
        """Emit error budget utilization metrics via Leyline"""

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_INFO,
            metrics=[
                MetricPoint(
                    name="slo_error_budget_utilization",
                    value=utilization,
                    type=MetricType.METRIC_GAUGE,
                    labels={
                        "slo_name": slo_name,
                        "subsystem": "jace"
                    },
                    timestamp=google.protobuf.Timestamp()
                ),
                MetricPoint(
                    name="slo_error_budget_burn_rate",
                    value=burn_rate,
                    type=MetricType.METRIC_GAUGE,
                    labels={
                        "slo_name": slo_name,
                        "subsystem": "jace"
                    },
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        self._send_telemetry_packet(telemetry_packet)

    def _calculate_burn_rate(self, slo_name: str) -> float:
        """Calculate error budget burn rate per hour"""

        measurements = self.slo_manager.measurements.get(slo_name, [])
        if len(measurements) < 2:
            return 0.0

        # Look at last hour of measurements
        one_hour_ago = time.time() - 3600
        recent_measurements = [m for m in measurements if m["timestamp"] > one_hour_ago]

        if not recent_measurements:
            return 0.0

        # Calculate violations in the last hour
        slo = self.slo_manager.slos[slo_name]
        violations = 0

        for measurement in recent_measurements:
            value = measurement["value"]

            if slo_name == "coordination_latency":
                if value > slo.target_value_ms:
                    violations += 1
            elif slo_name == "coordination_success_rate":
                if value < slo.target_value_ms:  # target_value_ms is success rate %
                    violations += 1
            elif slo_name == "fallback_rate":
                if value > slo.target_value_ms:  # target_value_ms is max fallback rate %
                    violations += 1

        # Convert violations to budget consumption per hour
        if violations == 0:
            return 0.0

        violation_weight = self.slo_manager._calculate_violation_weight(slo_name, 0)
        return violations * violation_weight

    def _get_budget_status(self, utilization: float) -> str:
        """Get budget status based on utilization"""

        if utilization >= 1.0:
            return "exhausted"
        elif utilization >= 0.8:
            return "critical"
        elif utilization >= 0.6:
            return "warning"
        else:
            return "healthy"

    def reset_error_budget(self, slo_name: str, reason: str = "Manual reset"):
        """Reset error budget for specific SLO with Leyline telemetry"""

        self.slo_manager.error_budget_consumed[slo_name] = 0.0
        self.budget_reset_times[slo_name] = time.time()

        logging.info(f"Error budget reset for {slo_name}: {reason}")

        # Emit budget reset event via Leyline
        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_INFO,
            events=[
                TelemetryEvent(
                    event_name="error_budget_reset",
                    severity=TelemetryLevel.TELEMETRY_INFO,
                    message=f"Error budget reset: {slo_name}",
                    attributes={
                        "slo_name": slo_name,
                        "reason": reason,
                        "subsystem": "jace"
                    },
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        self._send_telemetry_packet(telemetry_packet)

    def should_trigger_budget_alert(self, slo_name: str) -> bool:
        """Check if error budget consumption should trigger alert"""

        consumed = self.slo_manager.error_budget_consumed.get(slo_name, 0.0)
        budget = self.slo_manager.slos[slo_name].error_budget_percent

        utilization = consumed / budget if budget > 0 else 0.0

        # Alert thresholds
        return utilization > 0.75  # Alert when 75% of budget consumed
```

### 2.2 Conservative Mode Triggers

```python
def _trigger_conservative_mode(self, reason: str):
    """[C-016] Trigger conservative mode for SLO protection with Leyline telemetry"""

    if self.conservative_mode_active:
        return

    self.conservative_mode_active = True
    logging.warning(f"Triggering conservative mode: {reason}")

    # Conservative mode policies:
    # 1. Increase timing budgets by 50%
    for slo_name in self.slos:
        if "latency" in slo_name:
            self.slos[slo_name].target_value_ms *= 1.5

    # 2. Reset error budgets to allow recovery
    for slo_name in self.error_budget_consumed:
        self.error_budget_consumed[slo_name] *= 0.5  # Reduce by 50%

    # 3. Emit conservative mode activation via Leyline
    self._emit_conservative_mode_event("activated", reason)

    # 4. Emit metrics for monitoring
    self.metrics.conservative_mode_triggers.inc()

def _emit_conservative_mode_event(self, action: str, reason: str):
    """Emit conservative mode event via Leyline telemetry"""

    severity = TelemetryLevel.TELEMETRY_WARN if action == "activated" else TelemetryLevel.TELEMETRY_INFO

    telemetry_packet = TelemetryPacket(
        packet_id=str(uuid.uuid4()),
        timestamp=google.protobuf.Timestamp(),
        source_subsystem="jace",
        level=severity,
        events=[
            TelemetryEvent(
                event_name=f"conservative_mode_{action}",
                severity=severity,
                message=f"Conservative mode {action}: {reason}",
                attributes={
                    "action": action,
                    "reason": reason,
                    "subsystem": "jace",
                    "slo_active": str(self.conservative_mode_active)
                },
                timestamp=google.protobuf.Timestamp()
            )
        ]
    )

    self._send_telemetry_packet(telemetry_packet)

def reset_conservative_mode(self):
    """Reset conservative mode when SLOs recover"""

    if not self.conservative_mode_active:
        return

    # Check if all SLOs are healthy
    status = self.get_slo_status()
    all_healthy = all(
        slo_status["status"] == SLOStatus.HEALTHY
        for slo_name, slo_status in status.items()
        if slo_name != "overall_status" and slo_name != "conservative_mode_active"
    )

    if all_healthy:
        self.conservative_mode_active = False
        logging.info("Conservative mode deactivated - SLOs recovered")

        # Restore original timing budgets
        for slo_name, slo in self.slos.items():
            if "latency" in slo_name:
                self.slos[slo_name].target_value_ms /= 1.5

        # Emit conservative mode deactivation via Leyline
        self._emit_conservative_mode_event("deactivated", "SLOs recovered")
```

## 3. Performance Monitoring

### 3.1 Comprehensive SLO Status

```python
def get_slo_status(self) -> Dict[str, Any]:
    """Get current SLO status across all objectives with Leyline telemetry"""

    status = {}
    overall_status = SLOStatus.HEALTHY

    for slo_name, slo in self.slos.items():
        measurements = self.measurements[slo_name]

        if not measurements:
            slo_status = {
                "status": SLOStatus.HEALTHY,
                "current_percentile": None,
                "target": slo.target_value_ms,
                "error_budget_consumed": 0.0,
                "measurements_count": 0
            }
            status[slo_name] = slo_status
            continue

        # Calculate current percentile
        values = [m["value"] for m in measurements]
        values.sort()

        if slo.target_percentile == 100:
            current_value = max(values) if "rate" in slo_name else min(values)
        else:
            percentile_index = int((slo.target_percentile / 100.0) * len(values))
            current_value = values[min(percentile_index, len(values) - 1)]

        # Determine status
        budget_consumed = self.error_budget_consumed[slo_name]
        slo_status = SLOStatus.HEALTHY

        if budget_consumed > slo.error_budget_percent:
            slo_status = SLOStatus.CRITICAL
            overall_status = SLOStatus.CRITICAL
        elif budget_consumed > slo.error_budget_percent * 0.75:
            slo_status = SLOStatus.WARNING
            if overall_status == SLOStatus.HEALTHY:
                overall_status = SLOStatus.WARNING

        slo_status_dict = {
            "status": slo_status,
            "current_percentile": current_value,
            "target": slo.target_value_ms,
            "error_budget_consumed": budget_consumed,
            "measurements_count": len(measurements)
        }

        status[slo_name] = slo_status_dict

        # Emit SLO status via Leyline
        self._emit_slo_status_metric(slo_name, slo_status, current_value)

    status["overall_status"] = overall_status
    status["conservative_mode_active"] = self.conservative_mode_active

    # Emit overall status via Leyline
    self._emit_overall_slo_status(overall_status)

    return status

def _emit_slo_status_metric(self, slo_name: str, slo_status: SLOStatus, current_value: float):
    """Emit SLO status metric via Leyline"""

    # Map status to numeric value for metrics
    status_values = {
        SLOStatus.HEALTHY: 0,
        SLOStatus.WARNING: 1,
        SLOStatus.CRITICAL: 2,
        SLOStatus.EMERGENCY: 3
    }

    telemetry_packet = TelemetryPacket(
        packet_id=str(uuid.uuid4()),
        timestamp=google.protobuf.Timestamp(),
        source_subsystem="jace",
        level=TelemetryLevel.TELEMETRY_INFO,
        metrics=[
            MetricPoint(
                name="slo_status",
                value=status_values[slo_status],
                type=MetricType.METRIC_GAUGE,
                labels={
                    "slo_name": slo_name,
                    "status": slo_status.value,
                    "subsystem": "jace"
                },
                timestamp=google.protobuf.Timestamp()
            ),
            MetricPoint(
                name="slo_current_value",
                value=current_value or 0.0,
                type=MetricType.METRIC_GAUGE,
                labels={
                    "slo_name": slo_name,
                    "subsystem": "jace"
                },
                timestamp=google.protobuf.Timestamp()
            )
        ]
    )

    self._send_telemetry_packet(telemetry_packet)

def _emit_overall_slo_status(self, overall_status: SLOStatus):
    """Emit overall SLO status via Leyline"""

    status_values = {
        SLOStatus.HEALTHY: 0,
        SLOStatus.WARNING: 1,
        SLOStatus.CRITICAL: 2,
        SLOStatus.EMERGENCY: 3
    }

    telemetry_packet = TelemetryPacket(
        packet_id=str(uuid.uuid4()),
        timestamp=google.protobuf.Timestamp(),
        source_subsystem="jace",
        level=TelemetryLevel.TELEMETRY_INFO,
        metrics=[
            MetricPoint(
                name="slo_overall_status",
                value=status_values[overall_status],
                type=MetricType.METRIC_GAUGE,
                labels={
                    "status": overall_status.value,
                    "conservative_mode": str(self.conservative_mode_active),
                    "subsystem": "jace"
                },
                timestamp=google.protobuf.Timestamp()
            )
        ]
    )

    self._send_telemetry_packet(telemetry_packet)
```

### 3.2 Metrics Collection with Standardized Units

```python
from prometheus_client import Counter, Histogram, Gauge
from typing import Dict

class JaceMetrics:
    """[C-016] Comprehensive metrics with _ms standardization and Leyline integration"""

    def __init__(self):
        # Coordination metrics (all durations in milliseconds)
        self.coordination_decisions_total = Counter(
            'jace_coordination_decisions_total',
            'Total coordination decisions made',
            ['mode', 'fallback', 'conservative']
        )

        self.coordination_duration_ms = Histogram(
            'jace_coordination_duration_ms',  # [C-016] _ms suffix
            'Time taken for coordination decisions in milliseconds',
            ['mode', 'complexity'],
            buckets=[1, 5, 10, 15, 18, 25, 35, 50, 100, 500]
        )

        self.coordination_success_rate = Gauge(
            'jace_coordination_success_rate',
            'Success rate of coordination decisions',
            ['mode']
        )

        # Cache metrics
        self.cache_hits_total = Counter(
            'jace_cache_hits_total',
            'Total cache hits by level',
            ['level']  # l1, l2, l3
        )

        self.cache_misses_total = Counter(
            'jace_cache_misses_total',
            'Total cache misses'
        )

        self.cache_memory_usage_bytes = Gauge(
            'jace_cache_memory_usage_bytes',
            'Cache memory usage in bytes',
            ['level']
        )

        # [C-016] Circuit breaker metrics
        self.circuit_breaker_state = Gauge(
            'jace_circuit_breaker_state',
            'Circuit breaker state (0=closed, 1=open, 2=half_open)',
            ['breaker_name']
        )

        self.circuit_breaker_trips_total = Counter(
            'jace_circuit_breaker_trips_total',
            'Total circuit breaker trips',
            ['breaker_name', 'reason']
        )

        # [C-016] Conservative mode metrics
        self.conservative_mode_active = Gauge(
            'jace_conservative_mode_active',
            'Whether conservative mode is currently active'
        )

        self.conservative_mode_triggers_total = Counter(
            'jace_conservative_mode_triggers_total',
            'Total conservative mode activations',
            ['trigger_reason']
        )

        # [C-016] Memory management metrics
        self.memory_gc_operations_total = Counter(
            'jace_memory_gc_operations_total',
            'Total garbage collection operations',
            ['component']  # compatibility_cache, decision_cache, etc.
        )

        self.memory_entries_cleaned_total = Counter(
            'jace_memory_entries_cleaned_total',
            'Total memory entries cleaned up',
            ['component', 'reason']  # expired, size_limit, etc.
        )

        # SLO metrics
        self.slo_error_budget_consumed = Gauge(
            'jace_slo_error_budget_consumed',
            'SLO error budget consumed as percentage',
            ['slo_name']
        )

        self.slo_violations_total = Counter(
            'jace_slo_violations_total',
            'Total SLO violations',
            ['slo_name', 'severity']
        )

        # Compatibility matrix metrics
        self.compatibility_queries_total = Counter(
            'jace_compatibility_queries_total',
            'Total compatibility queries',
            ['cache_hit']
        )

        self.compatibility_score_distribution = Histogram(
            'jace_compatibility_score_distribution',
            'Distribution of compatibility scores',
            buckets=[0.0, 0.1, 0.3, 0.5, 0.7, 0.8, 0.9, 1.0]
        )

        # Leyline integration metrics
        self.leyline_message_size_bytes = Histogram(
            'jace_leyline_message_size_bytes',
            'Size of Leyline messages in bytes',
            ['message_type'],
            buckets=[50, 100, 150, 200, 250, 280, 350, 500]  # 280 is Leyline target
        )

        self.leyline_serialization_duration_us = Histogram(
            'jace_leyline_serialization_duration_us',
            'Time taken for Leyline message serialization in microseconds',
            ['message_type'],
            buckets=[10, 20, 40, 60, 80, 100, 150, 200]  # 80μs is Leyline target
        )

        self.leyline_contract_validation_failures = Counter(
            'jace_leyline_contract_validation_failures',
            'Failed Leyline contract validations',
            ['contract_type', 'failure_reason']
        )
```

## 4. Automated Conservative Mode Activation

### 4.1 Activation Conditions

```python
class ConservativeModeController:
    """Control conservative mode activation based on SLO violations with Leyline integration"""

    def __init__(self, slo_manager: JaceSLOManager):
        self.slo_manager = slo_manager
        self.activation_thresholds = {
            "coordination_latency": 0.8,  # 80% error budget consumption
            "coordination_success_rate": 0.5,  # 50% error budget consumption
            "fallback_rate": 0.7,  # 70% error budget consumption
        }

        self.consecutive_violations = {}
        self.activation_cooldown_seconds = 300  # 5 minutes between activations
        self.last_activation_time = 0

    def check_activation_conditions(self) -> bool:
        """Check if conservative mode should be activated"""

        current_time = time.time()

        # Check cooldown period
        if current_time - self.last_activation_time < self.activation_cooldown_seconds:
            return False

        # Check each SLO for activation conditions
        for slo_name, threshold in self.activation_thresholds.items():
            budget_consumed = self.slo_manager.error_budget_consumed.get(slo_name, 0.0)
            budget_limit = self.slo_manager.slos[slo_name].error_budget_percent

            utilization = budget_consumed / budget_limit if budget_limit > 0 else 0.0

            if utilization >= threshold:
                # Track consecutive violations
                self.consecutive_violations[slo_name] = self.consecutive_violations.get(slo_name, 0) + 1

                # Activate if we have multiple consecutive violations
                if self.consecutive_violations[slo_name] >= 3:
                    self._activate_conservative_mode(f"SLO {slo_name} budget {utilization:.1%} exceeds threshold {threshold:.1%}")
                    return True
            else:
                # Reset consecutive violations counter
                self.consecutive_violations[slo_name] = 0

        return False

    def _activate_conservative_mode(self, reason: str):
        """Activate conservative mode with Leyline telemetry"""

        self.slo_manager._trigger_conservative_mode(reason)
        self.last_activation_time = time.time()

        # Clear consecutive violations as we're now in conservative mode
        self.consecutive_violations.clear()

        # Emit activation telemetry via Leyline
        self._emit_activation_telemetry(reason)

    def _emit_activation_telemetry(self, reason: str):
        """Emit conservative mode activation via Leyline telemetry"""

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_WARN,
            events=[
                TelemetryEvent(
                    event_name="conservative_mode_controller_activation",
                    severity=TelemetryLevel.TELEMETRY_WARN,
                    message=f"Conservative mode controller activated: {reason}",
                    attributes={
                        "reason": reason,
                        "subsystem": "jace",
                        "controller": "slo_based"
                    },
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        self._send_telemetry_packet(telemetry_packet)

    def check_deactivation_conditions(self) -> bool:
        """Check if conservative mode should be deactivated"""

        if not self.slo_manager.conservative_mode_active:
            return False

        # Check if all SLOs are healthy for sustained period
        status = self.slo_manager.get_slo_status()

        all_healthy = all(
            slo_status["status"] == SLOStatus.HEALTHY
            for slo_name, slo_status in status.items()
            if slo_name not in ["overall_status", "conservative_mode_active"]
        )

        if all_healthy:
            self.slo_manager.reset_conservative_mode()

            # Emit deactivation telemetry via Leyline
            self._emit_deactivation_telemetry("All SLOs healthy")
            return True

        return False

    def _emit_deactivation_telemetry(self, reason: str):
        """Emit conservative mode deactivation via Leyline telemetry"""

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=TelemetryLevel.TELEMETRY_INFO,
            events=[
                TelemetryEvent(
                    event_name="conservative_mode_controller_deactivation",
                    severity=TelemetryLevel.TELEMETRY_INFO,
                    message=f"Conservative mode controller deactivated: {reason}",
                    attributes={
                        "reason": reason,
                        "subsystem": "jace",
                        "controller": "slo_based"
                    },
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        self._send_telemetry_packet(telemetry_packet)
```

## 5. Alerting and Notifications

### 5.1 SLO Alert Manager

```python
class SLOAlertManager:
    """Manage SLO-based alerting and notifications with Leyline integration"""

    def __init__(self, slo_manager: JaceSLOManager):
        self.slo_manager = slo_manager
        self.alert_history = []
        self.alert_cooldowns = {}

    def check_alert_conditions(self):
        """Check for conditions that should trigger alerts"""

        status = self.slo_manager.get_slo_status()
        current_time = time.time()

        for slo_name, slo_status in status.items():
            if slo_name in ["overall_status", "conservative_mode_active"]:
                continue

            alert_level = self._determine_alert_level(slo_status)

            if alert_level and self._should_send_alert(slo_name, alert_level, current_time):
                self._send_alert(slo_name, alert_level, slo_status)

    def _determine_alert_level(self, slo_status: Dict[str, Any]) -> Optional[str]:
        """Determine alert level based on SLO status"""

        status = slo_status["status"]
        budget_consumed = slo_status["error_budget_consumed"]

        if status == SLOStatus.CRITICAL:
            return "critical"
        elif status == SLOStatus.WARNING:
            return "warning"
        elif budget_consumed > 0.5:  # 50% budget consumed
            return "info"

        return None

    def _should_send_alert(self, slo_name: str, alert_level: str, current_time: float) -> bool:
        """Check if alert should be sent based on cooldown periods"""

        cooldown_key = f"{slo_name}_{alert_level}"
        cooldown_periods = {
            "info": 3600,      # 1 hour
            "warning": 1800,   # 30 minutes
            "critical": 300    # 5 minutes
        }

        last_alert_time = self.alert_cooldowns.get(cooldown_key, 0)
        cooldown_period = cooldown_periods.get(alert_level, 3600)

        return current_time - last_alert_time >= cooldown_period

    def _send_alert(self, slo_name: str, alert_level: str, slo_status: Dict[str, Any]):
        """Send alert notification via Leyline telemetry"""

        alert = {
            "timestamp": time.time(),
            "slo_name": slo_name,
            "alert_level": alert_level,
            "status": slo_status["status"].value,
            "current_value": slo_status["current_percentile"],
            "target_value": slo_status["target"],
            "error_budget_consumed": slo_status["error_budget_consumed"],
            "message": self._format_alert_message(slo_name, alert_level, slo_status)
        }

        self.alert_history.append(alert)
        self.alert_cooldowns[f"{slo_name}_{alert_level}"] = time.time()

        # Emit alert via Leyline telemetry
        self._emit_alert_telemetry(alert)

        # Send to monitoring/alerting system
        logging.warning(f"SLO Alert: {alert['message']}")

        # Integration with external alerting (Slack, PagerDuty, etc.)
        self._send_external_alert(alert)

    def _emit_alert_telemetry(self, alert: Dict[str, Any]):
        """Emit alert via Leyline telemetry"""

        severity_mapping = {
            "info": TelemetryLevel.TELEMETRY_INFO,
            "warning": TelemetryLevel.TELEMETRY_WARN,
            "critical": TelemetryLevel.TELEMETRY_ERROR
        }

        severity = severity_mapping.get(alert["alert_level"], TelemetryLevel.TELEMETRY_WARN)

        telemetry_packet = TelemetryPacket(
            packet_id=str(uuid.uuid4()),
            timestamp=google.protobuf.Timestamp(),
            source_subsystem="jace",
            level=severity,
            events=[
                TelemetryEvent(
                    event_name="slo_alert",
                    severity=severity,
                    message=alert["message"],
                    attributes={
                        "slo_name": alert["slo_name"],
                        "alert_level": alert["alert_level"],
                        "status": alert["status"],
                        "current_value": str(alert["current_value"] or 0),
                        "target_value": str(alert["target_value"]),
                        "budget_consumed": str(alert["error_budget_consumed"]),
                        "subsystem": "jace"
                    },
                    timestamp=google.protobuf.Timestamp()
                )
            ]
        )

        self._send_telemetry_packet(telemetry_packet)

    def _format_alert_message(self, slo_name: str, alert_level: str, slo_status: Dict[str, Any]) -> str:
        """Format human-readable alert message"""

        return f"""
        Jace SLO Alert: {slo_name.replace('_', ' ').title()}

        Level: {alert_level.upper()}
        Current: {slo_status['current_percentile']:.2f if slo_status['current_percentile'] else 'N/A'}
        Target: {slo_status['target']:.2f}
        Error Budget Consumed: {slo_status['error_budget_consumed']:.2f}%

        Action Required: {"Investigate immediately" if alert_level == "critical" else "Monitor closely"}
        """
```

## 6. Integration Contract

### 6.1 SLO Monitoring Interface

The SLO framework provides standardized interfaces for:

- **Measurement Recording**: `record_coordination_latency()`, `record_coordination_result()`
- **Status Monitoring**: `get_slo_status()`, `get_error_budget_status()`
- **Conservative Mode**: Automatic activation/deactivation based on SLO violations
- **Alert Integration**: Automated alerting when SLOs are violated
- **Leyline Integration**: All metrics and events reported via TelemetryPacket

### 6.2 Metrics Integration

- **Prometheus Metrics**: All SLO metrics exported with standardized naming
- **Leyline Telemetry**: Real-time metrics via TelemetryPacket for cross-subsystem visibility
- **Dashboard Integration**: Grafana dashboards for SLO monitoring using both Prometheus and Leyline data
- **Alert Manager**: Integration with external alerting systems
- **Historical Data**: Long-term SLO performance tracking

### 6.3 Administrative Controls

- **Manual Override**: Force conservative mode activation/deactivation
- **Budget Management**: Manual error budget resets when appropriate
- **Threshold Adjustment**: Dynamic SLO target adjustments
- **Alert Configuration**: Customizable alert thresholds and cooldowns
- **Leyline Message Inspection**: View and validate all Leyline telemetry messages

### 6.4 Leyline Integration Points

- **Performance Metrics**: SystemStatePacket latency and success rates
- **Error Budget Tracking**: TelemetryPacket metrics for cross-subsystem budget visibility
- **SLO Violations**: TelemetryEvent alerts for immediate cross-subsystem notification
- **Conservative Mode**: Status reporting via HealthStatus in SystemStatePacket
- **Circuit Breaker Coordination**: CircuitBreakerState integration with SLO thresholds

## 7. References

**Back to Main Document**: [11-jace-unified-design.md](11-jace-unified-design.md) - Core architecture and system overview
**Related Components**:
- [11.1-jace-testing-frameworks.md](11.1-jace-testing-frameworks.md) - Performance testing validates SLO targets
- [11.2-jace-circuit-breakers.md](11.2-jace-circuit-breakers.md) - Circuit breakers trigger SLO violations

**Leyline Integration**:
- Leyline Shared Contracts: 00-leyline-shared-contracts.md - Complete shared contract specifications
- C-018 Round 7 Consensus: Option B (Performance-First) implementation requirements

**External References**:
- Google SRE Book - Service Level Objectives
- Implementing Service Level Objectives - Alex Hidalgo
- Site Reliability Engineering Workbook - Google
- C-016 External Review - Performance and SLO Requirements